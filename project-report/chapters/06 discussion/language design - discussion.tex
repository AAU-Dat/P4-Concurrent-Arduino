\section{Language design}

This section will discuss the language design of Arc, the descisions made and what could have been done differently.

\subsection{Design descision} 
Many descision have to be made during language design, this section will discuss a few of those descisions made and alternative options.
As mentioned in section \todo{Add section reference}, Arc makes use of a single data type to represent all numbers, called num and is treated as a float. Compared to many other languages that include multiple different type to represent different categories of numbers. This descision was made, based on the assumption that using a single data type that represents all numbers, would be easier and faster to work with, compared to a system that would use e.g. Int and Float. In section \ref{subsec:numberAsFloats} some of the issues of this descision are briefly mentioned, such as the simple expression in listing \ref{lst:semanticDifference} evaluating to false, when logicly it should evaluate to true. This could prove difficult for new users to understand, and therefore make certain issues in a program hard to fix, as the solution is not entirly clear. For this reason it could be argued that dividing num into int and float, would be a better option. As this would solve some of the issues of num.

%Since Arc is a language based on giving access to simple use of concurrency, it is important that the constructs used for this, are simple and understandable. Arc ended up with three main concurrency structures, \textbf{When}, \textbf{Where}, and the idle task. The task construct uses the task keyword to define it as a function that works concurrently, then it has its trigger or event that executes the body of the task. There has been an effort in designing the triggers to be understood as they are read, the every trigger is a time based trigger, that can be read as: "This task will execute every 1000 miliseconds". The same concept holds for every. The task with no trigger is the idle task, which is the more abstract task of the three, as it does not have a direct trigger, instead it executes whenever possible. 

Paramaters given to a task are mutable, This was done in an effort to prevent issues, such as race condition. Although it might have been a better option to leave this up to the user to handle, giving them more control over the program. As they then would learn the concepts and issues that can arise from working with concurrency, and how to handle them accordingly.

Since no usability tests where able to be done for Arc, it is only an assumption that the trigger keywords of a task are understandable for users, and not just the developers. An alternative could have been the tasks being defined as either timed or event based tasks, instead of using a trigger keyword to define this. An example of this can be seen in Eventually\todo{Perhaps show this, ref it maybe?}, where there are different types of event listenerns, time and pin, that take different parameters, and behave differently. The descision to use the structure of the tasks where they are read as resembling spoken language, was made due to the assumption that this made it clear to users, how the different tasks were to be used.


%The parameters given to the task, are used as variables that can to be mutated in the task. An example of this would be if an LED was to blink every second, then that LED would have to be given as a paramater so that the task could modify its value. Only one task can have a given variable, if one task is given the LED variable, another task can not be given that same LED variable as a paramater. This is done to prevent issues including racecondition, by ensuring that only task can modify a variable. The assumption is that this will help users avoid unforseen issues. 



The body of the task, works the same way as a normal function. The assumption is that hobbysits that wish to work with and learn about concurrency, only need simple functions that can run concurrently. Therefore it made sense to structure the tasks in the same way as a regular function.

In general, there was given limited control over the concurrency structures, other libraries that were researched included options such as being able to give priorities to certain tasks. This was done in an effort to reduce complexity of the tasks as much as possible, since it was assumed that hobbyists who needed more complex functionality, would find and use other libraries. But an argument could be made, that the structures have been simplified too much and abstracted away options that could be useful for users. More options could have been made avaliable for users to work with, for better control over the concurrent tasks running. This might have slightly increased the complexity of Arc, but could also lead to better use of the concurrent tasks. For this project, the simplicity of Arc was a priority, therefore the more simplified concurrent tasks were used.


\subsection{Resemblence to C}
Arc uses a simillar syntax to that of C, this was done intentionally, but an argument can be made wether that was a good descision or not. C is a popular language and has a syntax simillar to that of many other languages. Therefore with Arc having a syntax that resembles C, would imply that users learning how to program with Arc, would have an easier time in the future learning new programming languages. Also if a user has had just a little experience with another programming language, that also has a simillar syntax to C, Arc would be more recognizable for them, and they should be able to learn how to work with concurrency faster. Arduino uses a subset of C++, and since C++ and C use very simillar syntax, it was easy to translate much of Arcs syntax to something that was able to compile on the Arduino.

Although it could be argued that using a syntax that resembles C, has limited the creativity of creating a unique programming language, that is specified to work with concurrency. It can be seen in the syntax of Arc, that does not work with concurrency, that much has not been changed compared to that of C, apart from the for loop, that resembles that of Python. An issues with this could be seen in a case where a user has difficulties understanding and using regular C.\question{Maybe just remove this sentence} This is often how new languages are made, taking inspiration from many other languages and implementing them into their own. The reason for this, is because the syntax for C is widely used, and there is no reason to try and make changes that do not serve any particular purpose. \question{MÃ¥ske skrive: and there is no reason to try and make changes for the sake of making changes}


\begin{listing}[htb!]
    \begin{minted}[label=Arc example]{text}
        #pin BUTTON_PIN(12, OUTPUT);
        mut num buttonState = 0;
        mut bool ledState = HIGH;

        task(bool ledState) every 1000 {
            ledState = not ledState;
            digitalWrite(LED_BUILTIN, ledState)
        }

        task(num buttonState) {
            buttonState = digitalRead(BUTTON_PIN);
            Serial.Println(buttonState);
        }
    \end{minted}
    \caption{Project example implemented in Arc, assuming print is possible.}
    \label{lst:arcexample}
\end{listing}