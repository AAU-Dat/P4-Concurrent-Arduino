\section{Language design}

This section will discuss the language design of Arc, the descisions made and what could have been done differently.

\subsection{Design descision} 
Many descision have to be made during language design, this section will discuss a few of those descisions made and alternative options.
As mentioned in section \todo{Add section reference}, Arc makes use of a single data type to represent all numbers, called num and is treated as a float. Compared to many other languages that include multiple different type to represent different categories of numbers. This descision was made, based on the assumption that using a single data type that represents all numbers, would be easier and faster to work with, compared to a system that would use e.g. Int and Float. In section \ref{subsec:numberAsFloats} some of the issues of this descision are briefly mentioned, such as the simple expression in listing \ref{lst:semanticDifference} evaluating to false, when logicly it should evaluate to true. This could prove difficult for new users to understand, and therefore make certain issues in a program hard to fix, as the solution is not entirly clear. For this reason it could be argued that dividing num into int and float, would be a better option. 

Since Arc is a language based on giving access to simple use of concurrency, it is important that the constructs used for this, are simple and understandable. The task construct uses the task keyword to define it as a function that works concurrently, then it has its trigger or event that executes the body of the task. There has been an effort in designing the triggers to be understood as they are read, the every trigger is a time based trigger, that can be read as: "This task will execute every 1000 miliseconds". The same concept holds for every. The task with no trigger is the idle task, which is the more abstract task of the three, as it does not have a direct trigger, instead it executes whenever possible. Since no usability tests where able to be done for Arc, it is only an assumption that these trigger keywords are understandable for users, and not just the developers. An alternative could have been the tasks being defined as either timed or event based tasks, instead of using a trigger keywork to define this, an example of this can be seen in Eventually\todo{Perhaps show this}, where there are different types of event listenerns, time and pin, that take different parameters, and behave differently. 

\todo[inline]{Operationalsemantics mentions moving a section here, that further discusses num vs int and float}

Another design descision worth discussing is the choice of scope and type rules of Arc. \todo[inline]{Read section 3.4 and continue from here}
%num vs int + float
    %num is easier to understand
        %Can lead to arithmetic issues
%Do tasks work as a construct
%Scope rules, type rules
    %Call by value vs call by reference
    %Semantics

\subsection{Resemblence to C}
%The good
Arc uses a simillar syntax to that of C, this was done intentionally, but an argument can be made wether that was a good descision or not. C is a popular language and has a syntax simillar to that of many other languages. Therefore with Arc having a syntax that resembles C, would imply that users learning how to program with Arc, would have an easier time in the future learning new programming languages. Also if a user has had just a little experience with another programming language, that also has a simillar syntax to C, Arc would be more recognizable for them, and they should be able to learn how to work with concurrency faster. Arduino uses a subset of C++, and since C++ and C use very simillar syntax, it was easy to translate much of Arcs syntax to something that was able to compile on the Arduino.
%The bad
Although it could be argued that using a syntax that resembles C, has limited the creativity of creating a unique programming language, that is specified to work with concurrency. It can be seen in the syntax of Arc, that does not work with concurrency, that much has not been changed compared to that of C, apart from the for loop, that resembles that of Python. An issues with this could be seen in a case where a user has difficulties understanding and using regular C.\question{Maybe just remove this sentence} This is often how new languages are made, taking inspiration from many other languages and implementing them into their own. The reason for this, is because the syntax for C is widely used, and there is no reason to try and make changes that do not serve any particular purpose. \question{MÃ¥ske skrive: and there is no reason to try and make changes for the sake of making changes}

%Challenges with concurrency
    %Complex subject
    %Simplified and limited use of concurrency
    %Arduino does not support true concurrency
    %Better start to paragraph
The design for Arc is made in a way, to give hobbyists a simple way to work with and learn how to use concurrency with an Arduino, to do this the library Protothreads has been used. Some challanges that were found during production of Arc, included that concurrency is a complex topic and proved hard to understand and use at times. Therefore it was difficult to simplify it to a level, that was assumed to be understandable for hobbyists. Arc ended up with three main concurrency structures, \textbf{When}, \textbf{Where}, and the idle task. These task were made in an effort to simplify concurrency to resemble somewhat spoken language. Because of this, there was given limited control over the concurrency structures, other libraries that were researched included options such as being able to give priorities to certain tasks. This was done in an effort to reduce complexity of the tasks as much as possible, since it was assumed that hobbyists who needed more complex functionality, would find and use other libraries. But an argument could be made, that the structures have been simplified too much and abstracted away options that could be useful for users. More options could have been made avaliable for users to work with, for better control over the concurrent tasks running. This might have slightly increased the complexity of Arc, but could also lead to better use of the concurrent tasks. For this project, the simplicity of Arc was a priority, therefore the more simplified concurrent tasks were used. \question{Needs to draw more attention to the aspect of resembling C}

\question{Show how Arc differs from Protothreads and discuss if it makes sence to use Arc over it}
\todo[inline]{add comparison between Arc and other languages such as Python, Kotlin etc.}


\begin{listing}[htb!]
    \begin{minted}[label=Arc example]{text}
        #pin BUTTON_PIN(12, OUTPUT);
        mut num buttonState = 0;
        mut bool ledState = HIGH;

        task(bool ledState) every 1000 {
            ledState = not ledState;
            digitalWrite(LED_BUILTIN, ledState)
        }

        task(num buttonState) {
            buttonState = digitalRead(BUTTON_PIN);
            Serial.Println(buttonState);
        }
    \end{minted}
    \caption{Project example implemented in Arc, assuming print is possible.}
    \label{lst:arcexample}
\end{listing}