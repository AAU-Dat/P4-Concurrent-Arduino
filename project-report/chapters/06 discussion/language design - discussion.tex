\section{Language design}

This section will discuss the language design of Arc, the decisions made, and what could have been done differently.

\subsection{Design descision} 
Many decisions have to be made during language design; this section will discuss a few of those decisions made and alternative options.
As mentioned in section \todo{Add section reference}, Arc makes use of a single data type to represent all numbers, called num, and is treated as afloat. Compared to many other languages that include multiple different types to represent different categories of numbers. This decision was made based on the assumption that using a single data type that represents all numbers would be easier and faster to work with than a system, e.g., Int and Float. In section \ref{subsec:numberAsFloats} some of the issues of this decision are briefly mentioned, such as the simple expression in listing \ref{lst:semanticDifference} evaluating to false, when logically it should evaluate to true. This could prove problematic for new users to understand and make specific issues in a program hard to fix, as the solution is not entirely clear. For this reason, it could be argued that dividing num into int and float would be a better option as this would solve some of the issues of num.

%Since Arc is a language based on giving access to simple use of concurrency, it is important that the constructs used for this, are simple and understandable. Arc ended up with three main concurrency structures, \textbf{When}, \textbf{Where}, and the idle task. The task construct uses the task keyword to define it as a function that works concurrently, then it has its trigger or event that executes the body of the task. There has been an effort in designing the triggers to be understood as they are read, the every trigger is a time based trigger, that can be read as: "This task will execute every 1000 miliseconds". The same concept holds for every. The task with no trigger is the idle task, which is the more abstract task of the three, as it does not have a direct trigger, instead it executes whenever possible. 

Parameters given to a task are mutable; this was done to prevent issues such as race conditions. Although it might have been a better option to leave this up to the user to handle, giving them more control over the program. They then would learn the concepts and issues that can arise from working with concurrency and how to handle them accordingly.

Since no usability tests were able to be done for Arc, it is only an assumption that a task's trigger keywords are understandable for users, not just the developers. An alternative could have been the tasks being either timed or event-based tasks instead of using a trigger keyword to define this. An example of this can be seen in Eventually\todo{Perhaps show this, ref it maybe?}, where there are different types of event listeners, time and pin, that take different parameters and behave differently. The decision to use the structure of the tasks where they are read as resembling spoken language was made because it made it clear to users how the different tasks were to be used.


%The parameters given to the task, are used as variables that can to be mutated in the task. An example of this would be if an LED was to blink every second, then that LED would have to be given as a paramater so that the task could modify its value. Only one task can have a given variable, if one task is given the LED variable, another task can not be given that same LED variable as a paramater. This is done to prevent issues including racecondition, by ensuring that only task can modify a variable. The assumption is that this will help users avoid unforseen issues. 



The body of the task works the same way as a normal function. The assumption is that hobbyists that wish to work with and learn about concurrency only need simple functions that can run concurrently. Therefore it made sense to structure the tasks in the same way as a regular function.

In general, there was given limited control over the concurrency structures, other libraries that were researched included options such as being able to give priorities to specific tasks. This was done to reduce the complexity of the tasks as much as possible since it was assumed that hobbyists who needed more complex functionality would find and use other libraries. However, an argument could be made that the structures have been simplified too much and abstracted away options that could be useful for users. More options could have been made available for users to work with for better control over the concurrent tasks running. This might have slightly increased the complexity of Arc but could also lead to better use of the concurrent tasks. For this project, the simplicity of Arc was a priority; therefore, the more simplified concurrent tasks were used.


\subsection{Resemblence to C}
Arc uses a similar syntax to that of C, this was done intentionally, but an argument can be made whether that was a good decision. C is a popular language and has a syntax similar to many other languages. Therefore, Arc has a syntax that resembles C, implying that users learning how to program with Arc would have an easier time learning new programming languages in the future. Also, if a user has had just a little experience with another programming language that also has a similar syntax to C, Arc would be more recognizable for them, and they should be able to learn how to work with concurrency faster. Arduino uses a subset of C++, and since C++ and C use very similar syntax, it was easy to translate much of Arc's syntax to something that was able to compile on the Arduino.

Although it could be argued that using a syntax resembling C has limited the creativity of creating a unique programming language specified to work with concurrency in the syntax of Arc, which does not work with concurrency; much has not been changed compared to that of C, apart from the for loop, that resembles that of Python. Any issues with this could be seen in a case where a user has difficulties understanding and using regular C.\question{Maybe remove this sentence} This is often how new languages are made, taking inspiration from many other languages and implementing them into their own. This is because the syntax for C is widely used, and there is no reason to try and make changes that do not serve any particular purpose. \question{MÃ¥ske skrive: and there is no reason to try and make changes for the sake of making changes}


\begin{listing}[htb!]
    \begin{minted}[label=Arc example]{text}
        #pin BUTTON_PIN(12, OUTPUT);
        mut num buttonState = 0;
        mut bool ledState = HIGH;

        task(bool ledState) every 1000 {
            ledState = not ledState;
            digitalWrite(LED_BUILTIN, ledState)
        }

        task(num buttonState) {
            buttonState = digitalRead(BUTTON_PIN);
            Serial.Println(buttonState);
        }
    \end{minted}
    \caption{Project example implemented in Arc, assuming print is possible.}
    \label{lst:arcexample}
\end{listing}