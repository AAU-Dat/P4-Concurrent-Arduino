\section{Language design}\label{sec:discussion_languageDesign}

This section aims to discuss some of the language design observations we have made about what could have been done differently.

\subsection{Design descision}

During the design of a programming language, decisions and delimitations are very important milestones. A chosen path can open new doors and inadvertently close others. Often, it is difficult to know the full effect of a single design choice until further down in the pipeline. This is a discussion about some of these choices we have made and how alternative choices could have influenced the project.

\subsubsection{All Numbers are Floating Points}

Arc uses a single collective data type for all numbers called 'num', and is treated as a floating point. While many other languages chooses to represent numbers with multiple data types depending on the qualities of the number, we decided that it might be easier (for our hobbyists) if they did not have to distinguish between floats, doubles, integers, etc. and just use a number variable. However, as we progressed on the project we discovered that the semantics of floating point arithmetics work differently than they do from a logical or mathematical position. Listing~\ref{lst:semanticDifference} shows how a seemingly legal expression in mathematics can be misinterpreted by the compiler when working with a floating point, rather than a real number.

\begin{listing}[htb!]
    \begin{minted}[label=Semantic meaning of floats]{c}
        print(0.1 + 0.2 == 0.3);
        print(0.1 + 0.2 == 0.30000000000000004);

        // Evaluates to true if real numbers, false if floats
        // Evaluates to false if real numbers, true if floats
    \end{minted}
    \caption{Example of difference between floating-point arithmetic and mathemematics.}
    \label{lst:semanticDifference}
\end{listing}

This makes it a problem for the hobbyist programmers having issues with their code not working as intended. And while Arc is being different from most other programming languages on this note, debugging the issues might prove too difficult for the average hobbyist. The inconsistency might even lead to the programmer feeling frustrated with the language, while the solution to the problem is not really clear and obvious. For this reason, we would chose differently the next time and make a clearer distinction between at least integers and floats.

\subsubsection{Concurrency Improvements}

Since Arc is a programming language designed to make concurrency more simple and acessible on the Arduino, with hobbyists as a target user - we needed to make the constructs both easy to understand and use. We ended up implementing a task construct that has three different concurrency structures: timed, conditional and unconditional. We have put in a lot of effort to make it read as prosaically as possible. For example, the unconditional tasks just executes whenever they can and reads intuitively as "Task (executes as often as possible)". Whereas, if the user wants a task that executes every other second, they simply write "Task (is executed) every 2000 (miliseconds)" or if they want a task to do something whenever a button is pressed, they write "Task (executes) when [trigger] (condition has been met)". All three tasks, can be seen written in code in Listing~\ref{lst:threeTaskExamples}.

\begin{listing}[htb!]
    \begin{minted}[label=Task Declarations]{c}
        Task () {...}                       // Unconditional
        Task () every 2000 {...}            // Timed
        Task () when (expression) {...}     // Conditional
    \end{minted}
    \caption{Example of the three task declarations.}
    \label{lst:threeTaskExamples}
\end{listing}

Task Parameters are mutable. This was done to prevent issues related to race conditions. Although, it might have been a better option to leave this up to the individual developer and thereby give them more control over their program. Then they would also have had an incentive to learn about common concepts and issues related to working with concurrency, and how to handle them when they inevitably come up now and then.

Since we did not have the time to conduct a proper usability test, we can only surmise that the keywords and syntax of our tasks are easy to understand for any potential users, not just to us. Alternatively, we could have made the tasks timed or event-based instead and used listeners to trigger the tasks, like it was done in Eventually (see Figure~\ref{lst:eventuallyexample}). Eventually creates two different event listeners called EvtPinListener and EvtTimeListener which takes different parameters and behave differently from each other. The reasoning behind our selected task structure was mostly due to the resemblance to colloquial language, which should make it easier to understand what is going on for hobbyist. However, without any substantial tests, conjectures about the results are many and varied.

The body of the task works about the same as any regular function. We assume that the hobbyists interested in concurrency mostly needs simple functions that can run concurrently. Therefore, it made sense to structure the tasks in a similar way to normal functions.

In general, a limited control over the concurrency structures in Arc is given to the user of the language. Other researched libraries included options such as prioritising certain tasks over others. We made the decision to reduce the complexity and make it beginner friendly, contingent on the fact that users needing more control and more complex functionality would find and use other already existing libraries or methods of achieving the desired behaviour. However, an argument could be made that the structures have been oversimplified and abstracted away useful options. More control of the control structures could have been relinquished, without increasing the complexity too much. For this project, the simplicity of Arc was a high priority. Therefore, we went with the more simplified concurrent tasks.

\subsection{Resemblance to the C Programming Language}

The syntax of Arc shares an uncanny resemblance to that of C. This was very intentional; but an argument can be made whether or not that was a good decision. C is a very popular language and has a similar syntax to a lot of different languages. It was thereby hoped to make it easier for the hobbyists to pick up a potential second language or bring in any prior knowledge and experience with another language. This would potentially make it both easier and faster for them to learn. Arduino uses a subset of C++, and since C++ and C use a very similar syntax, it was relatively easy for us to translate much of the relevant code to something compilable on the Arduino, and simply handle the boilerplate code behind the scenes.

By creating a syntax resembling C has arguably also made an impact on our creativity  in a limiting way when it comes to creating a unique programming language. We have not changed a lot of constructs compared to C, apart from the for loop which mostly resembles how it is done in Python. New languages are typically made out of frustration by a missing feature in another language or by believing that there is a better way to do something. They are more often than not, highly influenced by already existing languages.

\todo{Why is the example listing~\ref{lst:arcexample} there? it wasn't referenced or anything. Delete if it needs to go.}

\begin{listing}[htb!]
    \begin{minted}[label=Arc example]{text}
        #pin BUTTON_PIN(12, OUTPUT);
        mut num buttonState = 0;
        mut bool ledState = HIGH;

        task(bool ledState) every 1000 {
            ledState = not ledState;
            digitalWrite(LED_BUILTIN, ledState)
        }

        task(num buttonState) {
            buttonState = digitalRead(BUTTON_PIN);
            Serial.Println(buttonState);
        }
    \end{minted}
    \caption{Project example implemented in Arc, assuming print is possible.}
    \label{lst:arcexample}
\end{listing}