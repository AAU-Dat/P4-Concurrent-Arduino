%Implementation
%Was \gls{antlr} a good tool for us
%Antlr good for us since we are inexperinced and had to make many changes
%Have we actually used visitor pattern, if not why?
%Should we have included a front end for our compiler - flags
%AST
%Pattern of implementation strengths and weaknesses
%strengths and weaknesses of another implementation
\section{Parser generator}
With the amount of experience on how to write a compiler, before the project, it seemed as the obviouse choice to use a parser generator, compared to making one manually. For this, there were many different options, but for Arc, \gls{antlr} was choosen as the parser generator. The main reason for choosing \gls{antlr}, was that the group, fairly quickly understood how to setup and use \gls{antlr}. It could be argued that the other parser generators might also have been a valid option for Arc, but since time was a limiting factor, is made sense to use \gls{antlr}. Looking back at the other options, \gls{antlr} would still be choosen, because it is now the tool the group is comfotable with. One of the main reasons the group chose a parser generator, instead of making one, was the lack of experience, and a parser generator was a good tool, for writting a language with little experience. This lack of experience lead to many issues that had to be fixed, during the design of Arc. Doing this manually would prove very time consuming as everything would have to be re-made everytime an issue was found, with a parser generator an issue could be fixed, and the rest could be generated based on the fix.

\subsection{Visitor vs. listener pattern}
With the \gls{ast} generated by \gls{antlr}, it was discussed in the group what type of pattern, should be implemented into the compiler. The two patterns in debate were the visitor and listener pattern. The visitor pattern was choosen because \gls{antlr} made it possible to implement it right into the \gls{ast}. One big weakness a visitor pattern has, compared to the listener pattern, is when changing the grammar or making a lexial update to the language. When doing this, new code has to be written, for the language to support the change. With \gls{antlr}, the main weakness of a normal visitor pattern, is almost removed from the Arc language, as \gls{antlr} generates the code, which otherwise would have to be written by hand. The main strength, and why the visitor pattern was choosen in the Arc language was, that the visitor pattern makes it easy to make changes in the semantic and scope checking. If chars could be relational equal evaluated, the code would only have to be written in one place in the implemantation, this makes it easy if in the future, changes would come to the type check. 

