%Implementation
%Was ANTLR a good tool for us
%Antlr good for us since we are inexperinced and had to make many changes
%Have we actually used visitor pattern, if not why?
%Should we have included a front end for our compiler - flags
%AST
%Pattern of implementation strengths and weaknesses
%strengths and weaknesses of another implementation
\section*{Language discussion}
With the small sample of experience on how to write a compiler in the group before the project, it was quickly decided the group would use a parser generator. Antlr was the choosen parser generator, the main reason for choosing Antlr, was the group fairly quickly understood how to setup and understand how Antlr worked. Looking back at the other options, Antlr would still be choosen, because it is now the tool the group is comfotable with. One of the main reasons the group choose a parser generator, instead of making one, was the lack of experience, and a parser generator was a good tool, for writting a language with little experience.

With the \gls{ast} Antlr made, it was discussed in the group what type of pattern, should be implemented into the compiler. The two patterns in debate was, visitor and listener pattern. Visitor pattern was choosen because Antlr made it possible to implement right into the AST Antlr made. Because of the choice of a parser generator, visitor pattern made good sense, by exposing the big weakness a visitor pattern has, which is when changing the grammar or making an lexial update to the language, new code would have to be written, for the language to support the newcomming change. With the parser generator Antlr, the big weakness in a normal visitor pattern, is almost removed from the Arc language, as Antlr generates the code, which would have to be written by hand if not for Antlr. The great strength and why the visitor pattern was choosen in the Arc language was, the visitor pattern makes it easy to make changes into the semantic and scope checking. If chars could be relational equal evaluated, the code would only have to be written in one place in the implemantation, this makes it easy if in the future, changes would come to the type check. 

