%Implementation
%Was \gls{antlr} a good tool for us
%Antlr good for us since we are inexperinced and had to make many changes
%Have we actually used visitor pattern, if not why?
%Should we have included a front end for our compiler - flags
%AST
%Pattern of implementation strengths and weaknesses
%strengths and weaknesses of another implementation

%hvad har vi gjort, hvad har det gjort, hvad kunne vi have gjort
\section{Parser generator}
With the amount of experience on how to write a compiler, before the project, it seemed as the obviuus choice to use a parser generator. For parser generators, there were different options, but for Arc, \gls{antlr} was choosen as the parser generator. The main reason for choosing \gls{antlr}, was that the group, fairly quickly understood how to setup and use \gls{antlr}. 


Choosing \gls{antlr} saved time on writting the compiler, this was one of the main arguments on why using a parser generator was choosen. The lack of experience lead to many issues that had to be fixed in the grammar, during the design of Arc. This was benefitted by choosing \gls{antlr} as the fixes was not time consuming for the project by \gls{antlr} generating much code after the fixes had been choosen. 


It could be argued that other parser generators might also have been a valid option for Arc, but since time was a limiting factor, is made sense to use \gls{antlr}. By choosing \gls{javacc} the group would have to write more code, as \gls{javacc} generates less code and tokens than \gls{antlr}, and an other argument againt choosing \gls{javacc} was \gls{antlr} was easier to setup. An other option on a parser generator would be to make one by hand. Making a paser generator by hand would prove very time consuming as everything would have to be re-made everytime an issue was found. One of the main reasons the group chose a parser generator, instead of making one, was the lack of experience, and a parser generator was a good tool, for writting a language with little experience. Also with a parser generator an issue could be fixed, and the rest could be generated based on the fix. Looking back at the other options, \gls{antlr} would still be choosen, because it is now the tool the group is comfotable with as to why not choosing \gls{javacc}, and can be argued to be faster then making one by hand.

\subsection{Visitor vs. listener pattern}

%hvad har vi gjort
With the tokens generated by \gls{antlr}, it was discussed in the group what type of pattern Arc should have implemented into the compiler. The pattern choosen was the visitor pattern. This was choosen because the tokens \gls{antlr} made were to made to fit easy into the visitor pattern.
%hvad har det gjort
The main strength, and why the visitor pattern was choosen in the Arc language was, that the visitor pattern made it easy to make changes in the semantic and scope checking. 

One big weakness the visitor pattern had, was when changing the grammar or making a lexial update to the language. When doing a change in the grammar, new code has to be written for new tokens, for the language to support the change. With \gls{antlr}, the main weakness of a normal visitor pattern, is almost removed from the Arc language, as \gls{antlr} generates the code, which otherwise would have to be written by hand and would be more time consuming. 


%Hvad kunne vi have gjort
It could be argued that other patterns might also be a valid option for Arc. Another pattern the was considered was the listener pattern. The visitor pattern was choosen because \gls{antlr} made it possible to implement it right into the tokens generated. The \gls{antlr} book says \begin{quote}
    The biggest difference between the listener and visitor mechanisms is that listener methods are called by the ANTLR-provided walker object, whereas visitor methods must walk their children with explicit visit calls. Forgetting to invoke visit() on a node’s children means those subtrees don’t get visited. \cite{Parr2014}
\end{quote}
It was argued that the compiler did not need to visit all nodes, if they were not used. Therefore the visitor pattern was choosen.
 






