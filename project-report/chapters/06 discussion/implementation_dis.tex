\section{Parser generator}\label{sec:discussion_parserGenerator}

The choice to use a parser generator seemed like an obvious choice after having read into the benefits. The choice quickly fell on \gls{antlr}, because of how fast and easy it was to get going with the tools. It saved us a lot of time on writing the compiler, not having to do it all by hand. Our lack of experience with making a language and using \gls{antlr} led to many issues of various severity; but it also brought a lot of great learning opportunities with it. During the design of Arc we made a lot of edits to our grammar file, which in turn had a huge impact on the time it took for us to implement the changes. It felt like a safe space to learn and play around with different solutions, rather than stressing to reach the finish line, which has been very beneficial looking at it with hindsight.

While a lot of focus has been put on \gls{antlr}, a case could be made that other parser generators might have been a valid option for Arc too; but the tools has served us well. If we had gone with \gls{javacc} the group would have had to write more code, while \gls{javacc} generates less code in comparison. \gls{antlr} was also easier and faster to setup and work with. We could also have made our own parser, but that would have brought with it a great decrement in time and increasingly frustrating, considering that the subject was new to us and time spent on updating the parser and lexers would take away time for improving the language and learning good practices from how the researched tools do their thing. If we were to develop a new language, we would still choose to use \gls{antlr}, but we would have a deeper understanding of the entire process and appreciation of the tool.

%We have learned a lot about parsers and lexers from the semester courses and from reviewing \gls{antlr}s generated files and documentation. Writing our own from scratch could also have been an enriching educational opportunity. This would also have meant considerably extra development time, while any potential changes also need to be reflected in all layers of the code. One small change to the grammar file would also have to be changed in both the lexer and the parser. Using \gls{antlr} to handle that has saved us time and energy so that we could focus on learning rather than maintaining a custom solution.

\subsection{Visitor or Listener Patterns}

After having read the \gls{antlr} book~\cite{Parr2014}, we discussed which type of pattern to use for traversing the tree created by \gls{antlr}. We decided it was best to use the visitor pattern for more control over the walker. We could easily decide how and when everything is visited, rather than being confined to the route of the walker.

One significant weakness connected to the visitor pattern compared to the listener pattern, is scalability. The changes in the grammar is also reflected in the listener, because it changes the path of the walker and everything is automated. Whereas we had to write new code for new tokens, when updating the grammar using the visitor pattern. However, even with this weakness, \gls{antlr} did a great job at making this easier, because it also updated the abstract base visitor to reflect the changes, meaning we only had to update the code in our custom visitor classes. By developing our own parser solution from scratch, we would also have to update these things ourselves.