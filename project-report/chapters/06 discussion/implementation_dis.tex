\section{Parser generator}\label{sec:discussion_parserGenerator}

The choice to use a parser generator seemed like an obvious choice after reading into the benefits. The choice quickly fell on \gls{antlr} because of how fast and easy it was to get going with the tools. It saved us much time writing the compiler, not having to do it all by hand. Our lack of experience with making a language and using \gls{antlr} led to various issues of various severity, but it also brought a lot of great learning opportunities. During the design of Arc, we made many edits to our grammar file, which had a significant impact on the time it took for us to implement the changes. It felt like a safe space to learn and play around with different solutions rather than stressing to reach the finish line, which has been very beneficial in hindsight.

While \gls{antlr} has had the most focus, alternative parser generators could also have been a valid option for Arc, but it would have impacted our project in another way. For example, if we had gone with \gls{javacc}, the group would have had to write more code because it generated less. \gls{antlr} was also easier and faster to set up and work with than \gls{javacc}. We could also have made a custom parser, but that would have brought a significant decrement in time and been increasingly frustrating. While the subject was new to us, any time spent on updating the parser and lexers would mean less time to improve the language and learn good practices from how the researched tools do their thing. If we were to develop a new language, we would still choose to use \gls{antlr}, but we would have a deeper understanding of the entire process and appreciation of the tool.

\subsection{Visitor or Listener Patterns}

After reading the \gls{antlr} book~\cite{Parr2014}, we discussed which type of pattern to use to traverse the tree created by \gls{antlr}. We decided it was best to use the visitor pattern for more control over the walker. We could easily decide how and when visitation happens, rather than confining ourselves to the walker's route.

One significant weakness associated with the visitor pattern compared to the listener pattern is scalability. Any changes in the grammar also need to be reflected in the listener, but it does this automatically. In contrast, we had to write new code for new tokens when updating the grammar using the visitor pattern. However, even with this weakness, \gls{antlr} did a great job at making this more manageable because it also updated the abstract base visitor to reflect the changes, meaning we only had to update the code in our custom visitor classes. We would also have to update these things ourselves if we were to develop a custom parser solution from scratch.