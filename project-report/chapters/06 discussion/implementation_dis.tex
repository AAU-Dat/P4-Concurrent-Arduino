\section{Parser generator}\label{sec:discussion_parserGenerator}

With the amount of experience in how to write a compiler before the project, it seemed like the obvious choice to use a parser generator. For parser generators, there were different options, but for Arc, \gls{antlr} was chosen as the parser generator. The main reason for choosing \gls{antlr}, was that the group reasonably quickly understood how to set up and use \gls{antlr}. 


Choosing \gls{antlr} saved time on writing the compiler; this was one of the main arguments on why using a parser generator was chosen. The lack of experience led to many issues that had to be fixed in the grammar during the design of Arc. This benefitted by choosing \gls{antlr} as the fixes were not time-consuming for the project by \gls{antlr} generating much code after the fixes had been chosen. 


It could be argued that other parser generators might also have been a valid option for Arc, but since time was a limiting factor, it made sense to use \gls{antlr}. By choosing \gls{javacc} the group would have to write more code, as \gls{javacc} generates less code and tokens than \gls{antlr}, and another argument against choosing \gls{javacc} was \gls{antlr} was more accessible to setup. Another option for a parser generator would be to make one by hand. Making a parser generator by hand would prove very time-consuming as everything would have to be re-made every time an issue was found. One of the main reasons the group chose a parser generator instead of making one was the lack of experience. A parser generator was a good tool for writing a language with little experience. Also, an issue could be fixed with a parser generator, and the rest could be generated based on the fix. Looking back at the other options, \gls{antlr} would still be chosen because it is now the tool the group is comfortable with as to why not choosing \gls{javacc}, and can be argued to be faster than making one by hand.

\subsection{Visitor vs. listener pattern}

%hvad har vi gjort
With the tokens generated by \gls{antlr}, it was discussed in the group what type of pattern Arc should have implemented into the compiler. The pattern chosen was the visitor pattern. This was chosen because the tokens \gls{antlr} made were made to fit easily into the visitor pattern.
%hvad har det gjort
The main strength and why the visitor pattern was chosen in the Arc language was that the visitor pattern made it easy to make changes in the semantic and scope checking. 

One significant weakness the visitor pattern had was changing the grammar or making a lexical update to the language. When changing the grammar, new code has to be written for new tokens for the language to support the change. With \gls{antlr}, the main weakness of a typical visitor pattern is almost removed from the Arc language, as \gls{antlr} generates the code, which otherwise would have to be written by hand and would be more time-consuming. 


%Hvad kunne vi have gjort
It could be argued that other patterns might also be a valid option for Arc. Another pattern that was considered was the listener pattern. The visitor pattern was chosen because \gls{antlr} made it possible to implement it right into the tokens generated. The \gls{antlr} book says \begin{quote}
    The biggest difference between the listener and visitor mechanisms is that the ANTLR-provided walker object calls that listener method. In contrast, visitors must walk their children with explicit visit calls. Forgetting to invoke visit() on a nodeâ€™s children means those subtrees do not get visited. \cite{Parr2014}
\end{quote}
It was argued that the compiler did not need to visit all nodes if they were not used. Therefore the visitor pattern was chosen.
 






