\subsection{Type rules}\label{subsec:typerules}



%type rules of c++
%general type rules of Arc
%mutability in Arc
%call by value, call by name, and call by reference
%recursive calls and function calls within functions and tasks

%There are 4 data types in C++, character types, integer types, floating types and boolean types.
%The character type in C++ is alot like the character type in Arc, the difference is when assinging, in Arc it is with "", in C++ more marks can be used as brackets such as ´´, '', ``, and "".
%The floating type is the data type the Arc data type num evaluates to. Therefore it shares many operations that can be made onto a data type float in Arc.
%The boolean data type works the same in Arc as in C++, there are therefore 2 values whitch the type can have.
%The integer data type in C++ does not correspond to anything in the Arc language, therefore it is not discussed further.

When designing a programming language, it is a good idea to have rules for specific types, this is called type rules. It should not be possible to assign a number to a type Boolean. 
The types that are valid in Arc are num, char and bool, they were descriped in further detail in\ref*{sec:inspiration}.

Types in semantics for the Arc language can be written as:
$T \in \{num, char, bool, N\} N \in \{ 0,\mathbb{N}\}$.
N was not descriped ealier on what the types are in Arc. 
N is only used to access arrays. 
For accessing an array, it has to have a natural number as index, in Arc an array is 0-indexed, therefore N can also be 0.  
From now on semantics written mathmatticly will use T instead of type, if not given a specific type, in semantic type checking.

Now that the types has been clarified, it is important to look at operations a specific type can do.
The first type that will be clarified is num.
In \ref{tab:num-rules} the expressions which the data type num only can do is showed here.

\begin{table}[htb!]
    \centering
    \begin{tabular}{lr>{\raggedright\arraybackslash}p{6cm}}
        $[ADD_{EXPR}] $                         & $\dfrac
            {env\vdash expr_1: num \quad env\vdash expr_2: num}
            {env\vdash expr_1 \;+\;expr_2: num}$
        \\
        \\
        $[SUB_{EXPR}] $                         & $\dfrac
            {env\vdash expr_1: num \quad env\vdash expr_2: num}
            {env\vdash expr_1 \;-\;expr_2: num}$
        \\
        \\
        $[MULT_{EXPR}] $                        & $\dfrac
            {env\vdash expr_1: num \quad env\vdash expr_2: num}
            {env\vdash expr_1 \;*\;expr_2: num}$
        \\
        \\
        $[DIVI_{EXPR}] $                        & $\dfrac
            {env\vdash expr_1: num \quad env\vdash expr_2: num}
        {env\vdash expr_1 \; / \; expr_2: num}$ & Where $expr_2 \neq 0$
        \\
        \\
        $[GREAT-THAN-QUAL_{EXPR}] $             & $\dfrac
            {env\vdash expr_1: num \quad env\vdash expr_2: num}
            {env\vdash expr_1 \; OP \; expr_2: Bool}$                   \\ & where $OP \in \{<, >, \leq, \geq\}$

        \\
        \\
    \end{tabular}
    \caption{Type rules for num in Arc}
    \label{tab:num-rules}
\end{table}
\todo[inline]{rename $[GREAT-THAN-QUAL_{EXPR}] $}
As it only is the expressions the type num can do, it is only the most standard expressions.
However
\begin{table}
    \centering
    \begin{tabular}{lr>{\raggedright\arraybackslash}p{6cm}}
        $[ARRAY_{EXPR}]$       & $ \dfrac
            {env\vdash expr_1: T \quad env \vdash expr_2 : N}
            {env\vdash expr_1[expr_2] : T}$
        \\
        \\
        $[PARANTHESES_{EXPR}]$ & $ \dfrac
            {env\vdash expr_1: T}
            {env\vdash (expr_1) : T}$
        \\
        \\
        $[EQUAL_{EXPR}] $      & $\dfrac
            {env\vdash expr_1: T \quad env\vdash expr_2: T}
            {env\vdash expr_1 \;= \;expr_2: Bool}$
        \\
        \\
        $[NOTEQUAL_{EXPR}] $   & $\dfrac
            {env\vdash expr_1: T \quad env\vdash expr_2: T}
            {env\vdash expr_1 \;!= \;expr_2: Bool}$
        \\
        \\
        $[AND_{EXPR}] $        & $\dfrac
            {env\vdash expr_1: Bool \quad env\vdash expr_2: Bool}
            {env\vdash expr_1 \;\land \;expr_2: Bool}$
        \\
        \\
        $[OR_{EXPR}] $         & $\dfrac
            {env\vdash expr_1: Bool \quad env\vdash expr_2: Bool}
            {env\vdash expr_1 \;\lor \;expr_2: Bool}$
        \\
        \\
        $[NOT_{EXPR}] $        & $\dfrac
            {env\vdash expr_1: Bool}
            {env\vdash not \; expr_1 : Bool}$
        \\
        \\
    \end{tabular}
    \caption{Type rules for all expressions in Arc}
    \label{tab:expr-rules}
\end{table}

\begin{table}[htbp]
    \centering
    \begin{tabular}{ll}
        $[COMP_{STMT}] $         & $\dfrac
            {env \vdash stmt_1 :ok \quad env \vdash stmt_2 :ok}
            {env \vdash stmt_1\;;\;stmt_2: ok}$
        \\
        \\
        $[VAR-DECL_{STMT}] $     & $\dfrac
            {env \vdash x : T \quad env \vdash expr : T}
            {env \vdash x = expr: ok}$
        \\
        \\
        $[ASSIGN_{STMT}]$        & $\dfrac
            {env\vdash x: T \quad env \vdash expr : T}
            {env\vdash x = expr: ok}$
        \\
        \\
        $[ASSIGN-ARRAY_{STMT}] $ & $\dfrac
            {env \vdash x : T \quad env \vdash expr : N \quad env \vdash expr : T}
            {env \vdash x[expr] = expr: ok}$
        \\
        \\
        $[BLOCK_{STMT}] $        & $\dfrac
            {env \vdash stmt :ok}
            {env \vdash \{stmt\}: ok}$
        \\
        \\
        $[CALL_{STMT}] $         & $\dfrac
            {env \vdash f:(x:T \rightarrow ok)\quad env \vdash expr:ok}
            {env \vdash call \;f(expr): ok}$
        \\
        \\
        $[RETURN_{STMT}] $       & $\dfrac
            {env \vdash expr:ok}
            {env \vdash return \;expr: ok}$
        \\
        \\
        $[IF_{STMT}] $           & $\dfrac
            {env \vdash if (expr) : Bool \quad env \vdash stmt_1 :ok \quad env \vdash stmt_2 :ok}
            {env \vdash if (expr) \;stmt_1 \;else \;stmt_2: ok}$
        \\
        \\
        $[WHILE_{STMT}] $        & $\dfrac
            {env \vdash  expr : Bool \quad env \vdash stmt :ok}
            {env \vdash while (expr) \;stmt : ok}$
        \\
        \\
        $[FOR_{STMT}] $          & $\dfrac
            {env \vdash  y : T \quad env \vdash x : T \quad env \vdash block :ok}
            {env \vdash for (y \; in \; x) \; block : ok}$
        \\
        \\
    \end{tabular}
    \caption{Arc type check statements}
    \label{tab:StatementTypeCheck}
\end{table}

\begin{table}[htbp]
    \centering
    \begin{tabular}{ll}
        $[VAR_{DECL}] $       & $\dfrac
            {expr : T}
            {T \;x = expr : ok}$
        \\
        \\
        $[FUNC_{DECL}] $      & $\dfrac
            {return \; expr : T}
            {T \;x\{stmt \;return \; expr\}  : ok}$
        \\
        \\
        $[FUNC-VOID_{DECL}] $ & $\dfrac
            {return \; expr : T}
            {x\{stmt\}  : ok}$
        \\
        \\
    \end{tabular}
    \caption{Arc type check for declarations}
    \label{tab:DeclTypeCheck}
\end{table}