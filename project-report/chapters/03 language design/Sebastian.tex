\subsection{Type rules}\label{subsec:typerules}



%type rules of c++
%general type rules of Arc
%mutability in Arc
%call by value, call by name, and call by reference
%recursive calls and function calls within functions and tasks

%There are 4 data types in C++, character types, integer types, floating types and boolean types.
%The character type in C++ is alot like the character type in Arc, the difference is when assinging, in Arc it is with "", in C++ more marks can be used as brackets such as ´´, '', ``, and "".
%The floating type is the data type the Arc data type num evaluates to. Therefore it shares many operations that can be made onto a data type float in Arc.
%The boolean data type works the same in Arc as in C++, there are therefore 2 values whitch the type can have.
%The integer data type in C++ does not correspond to anything in the Arc language, therefore it is not discussed further.

When designing a programming language, it is a good idea to have rules for specific types, this is called type rules. These rules are set up to make sure, it should not be possible to assign a number to a type Boolean. 
The types that are valid in Arc are num, char and bool, they were descriped in further detail in \ref*{sec:inspiration}.

In the type checking semantics the types in the Arc language are be written as:
$T \in \{num, char, bool, N\} N \in \{ 0,\mathbb{N}\}$.
From now on semantics written mathmatticly will use T instead of type, if not given a specific type, in semantic type checking.
N is not descriped ealier on what the types are in Arc, as it is not a type that can be declared, N is only used to access arrays. N is used for accessing an array, In C++ array access has a have a natural number, as weel as Arc. In C++ it is also 0-indexed, which is withhold in Arc aswell.  
In declarations and statements type checking, there will be an evaluation to $ok$ which means: \begin{quote}
    "The type of a declaration or a statement will simply be ok; we say that
the declaration or statement is well-typed"\cite{Huttel2010}
\end{quote}

In table \ref*{tab:DeclTypeCheck}, the type checking for variables are written. A specific type function declaration, has to type check if the return type is the same type as the declared function type. As task and a void function does not have a return type, there is not a need for type check, the void function is to illustrate how it would be written.

\begin{table}[htb!]
    \centering
    \begin{tabular}{ll}
        $[VAR_{DECL}] $       & $\dfrac
            {expr : T}
            {T \;x = expr : ok}$
        \\
        \\
        $[FUNC_{DECL}] $      & $\dfrac
            {env \vdash expr : T \quad stmt : ok}
            {T \;f \{stmt \;\text{return} \; expr\}  : ok}$
        \\
        \\
        $[FUNC-VOID_{DECL}] $ & $\dfrac
            {\text{stmt} : ok}
            {f\{stmt\}  : ok}$
        \\
        \\
    \end{tabular}
    \caption{Arc type check for declarations}
    \label{tab:DeclTypeCheck}
\end{table}

Now that the types has been clarified, it is important to look at operations a specific type can do.
The first type that will be clarified is num.
In \ref{tab:num-rules} the expressions which the data type num only can do, is showed here.

\begin{table}[htb!]
    \centering
    \begin{tabular}{lr>{\raggedright\arraybackslash}p{6cm}}
        $[ADD_{EXPR}] $                         & $\dfrac
            {env\vdash expr_1: num \quad env\vdash expr_2: num}
            {env\vdash expr_1 \;+\;expr_2: num}$
        \\
        \\
        $[SUB_{EXPR}] $                         & $\dfrac
            {env\vdash expr_1: num \quad env\vdash expr_2: num}
            {env\vdash expr_1 \;-\;expr_2: num}$
        \\
        \\
        $[MULT_{EXPR}] $                        & $\dfrac
            {env\vdash expr_1: num \quad env\vdash expr_2: num}
            {env\vdash expr_1 \;*\;expr_2: num}$
        \\
        \\
        $[DIVI_{EXPR}] $                        & $\dfrac
            {env\vdash expr_1: num \quad env\vdash expr_2: num}
        {env\vdash expr_1 \; / \; expr_2: num}$ & Where $expr_2 \neq 0$
        \\
        \\
        $[GREAT-THAN-QUAL_{EXPR}] $             & $\dfrac
            {env\vdash expr_1: num \quad env\vdash expr_2: num}
            {env\vdash expr_1 \; OP \; expr_2: Bool}$                   \\ & where $OP \in \{<, >, \leq, \geq\}$

        \\
        \\
    \end{tabular}
    \caption{Type rules for num expressions in Arc}
    \label{tab:num-rules}
\end{table}
\todo[inline]{rename $[GREAT-THAN-QUAL_{EXPR}] $}

The type num is the only type in Arc that can do arithmetic expressions, as it can only do arithmetic expressions on another num type, this can be seen in Table \ref*{tab:num-rules}. The end type of a arithmetic expression is still a num, as it makes changes the value, not the type. It is also the only type to check if a value is greater or smaller than an other num type when comparing. When doing a comparing of nums, the end type of the expression is a bool, as it true or false if the num is greater or less than the num it is compared to.

\begin{table}[htb!]
    \centering
    \begin{tabular}{lr>{\raggedright\arraybackslash}p{6cm}}
    $[AND_{EXPR}] $        & $\dfrac
        {env\vdash expr_1: Bool \quad env\vdash expr_2: Bool}
        {env\vdash expr_1 \;\text{and} \;expr_2: Bool}$
    \\
    \\
    $[OR_{EXPR}] $         & $\dfrac
        {env\vdash expr_1: Bool \quad env\vdash expr_2: Bool}
        {env\vdash expr_1 \;\text{or} \;expr_2: Bool}$
    \\
    \\
    $[NOT_{EXPR}] $        & $\dfrac
        {env\vdash expr_1: Bool}
        {env\vdash \text{not} \; expr_1 : Bool}$
    \\
    \\
    \end{tabular}
    \caption{Type rules for bool expressions in Arc}
    \label{tab:bool-rules}
\end{table}

The type bool has three expressions, that are marked as a bool type check, can be seen in table \ref*{tab:bool-rules}. This means in the And, Or or Not expressions the expression getting type checked has to evaluate to a bool, the expressions will then evaluate to another type bool. 

\begin{table}[htb!]
    \centering
    \begin{tabular}{lr>{\raggedright\arraybackslash}p{6cm}}
        $[ARRAY_{EXPR}]$       & $ \dfrac
            {env\vdash expr_1: T \quad env \vdash expr_2 : N}
            {env\vdash expr_1[expr_2] : T}$
        \\
        \\
        $[PARANTHESES_{EXPR}]$ & $ \dfrac
            {env\vdash expr_1: T}
            {env\vdash (expr_1) : T}$
        \\
        \\
        $[EQUAL_{EXPR}] $      & $\dfrac
            {env\vdash expr_1: T \quad env\vdash expr_2: T}
            {env\vdash expr_1 \;== \;expr_2: Bool}$
        \\
        \\
        $[NOTEQUAL_{EXPR}] $   & $\dfrac
        {env\vdash expr_1: T \quad env\vdash expr_2: T}
        {env\vdash expr_1 \;!= \;expr_2: Bool}$
    \\
    \\
    \end{tabular}
    \caption{Type rules for all type of expressions in Arc}
    \label{tab:expr-rules}
\end{table}

The type char does not have any expressions that only can be used on that type, therfore it only can use the expressions which bool and num can do as well. These type rules for expressions is written on table \ref*{tab:expr-rules}. In the array expression the type N is used to describe the index for the array. The equal and not equal expression evaluate to a bool type, as it can only be true or false.

\begin{table}[htb!]
    \centering
    \begin{tabular}{ll}
        $[COMP_{STMT}] $         & $\dfrac
            {env \vdash stmt_1 :ok \quad env \vdash stmt_2 :ok}
            {env \vdash stmt_1\;;\;stmt_2: ok}$
        \\
        \\
        $[VAR-DECL_{STMT}] $     & $\dfrac
            {env \vdash expr : T}
            {env \vdash  T \;x = expr: ok}$
        \\
        \\
        $[ASSIGN_{STMT}]$        & $\dfrac
            {env\vdash x: T \quad env \vdash expr : T}
            {env\vdash x = expr: ok}$
        \\
        \\
        $[ASSIGN-ARRAY_{STMT}] $ & $\dfrac
            {env \vdash x : T \quad env \vdash expr : N \quad env \vdash expr : T}
            {env \vdash x[expr] = expr: ok}$
        \\
        \\
        $[BLOCK_{STMT}] $        & $\dfrac
            {env \vdash stmt :ok}
            {env \vdash \{stmt\}: ok}$
        \\
        \\
        $[CALL_{STMT}] $         & $\dfrac
            {env \vdash f:(x:T \rightarrow ok)\quad env \vdash expr:ok}
            {env \vdash call \;f(expr): ok}$
        \\
        \\
        $[RETURN_{STMT}] $       & $\dfrac
            {env \vdash expr: T}
            {env \vdash \text{return} \;expr: ok}$
        \\
        \\
        $[IF_{STMT}] $           & $\dfrac
            {env \vdash if (expr) : Bool \quad env \vdash stmt_1 :ok \quad env \vdash stmt_2 :ok}
            {env \vdash \text{if} (expr) \;stmt_1 \;\text{else} \;stmt_2: ok}$
        \\
        \\
        $[WHILE_{STMT}] $        & $\dfrac
            {env \vdash  expr : Bool \quad env \vdash stmt :ok}
            {env \vdash \text{while} (expr) \;stmt : ok}$
        \\
        \\
        $[FOR_{STMT}] $          & $\dfrac
            {env \vdash  y : T \quad env \vdash x : T \quad env \vdash block :ok}
            {env \vdash \text{for} (y \; \text{in} \; x) \; block : ok}$
        \\
        \\
    \end{tabular}
    \caption{Arc type check statements}
    \label{tab:StatementTypeCheck}
\end{table}

The type checking for statements in Arc can be seen in table \ref*{tab:StatementTypeCheck}. Type checking statements gives the same output as the declarations in "ok", as explained before means well-typed. A varable can be declared in a scope, therfore it has the same type check rules as in variable declaration, which can be seen in table \ref*{tab:DeclTypeCheck}. Return uses an expression which evaluates to a type "T", this type is the same type as the type a function is declared with. 