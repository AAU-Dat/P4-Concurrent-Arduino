\section{Visitor pattern}\label{sec:visitorpattern}\feedback{We still working on this section, and unsure what is missing}
% This section will briefly discuss the two methods ANTLR provides of traversing a \gls{cst}, listeners and visitors, what they are, how they are used, and why they are used in Arc.

% The listener pattern, is not responsible for calling methods to traverse the tree. ANTLR generates enter and exit methods for each rule, these methods are then called when the walker encounters a node. The benefits of using the listener pattern, is that it is automatic, and the methods created do not have to explicitly visit all their child nodes\cite{Parr2014}. \feedback{We are unsure of how correct this actually is, taken from: Page 18}

The visitor pattern, is a method used to traverse the \gls{cst} in a specific manner, where methods are used to visit each child node. By using the visitor pattern, there is more control of how the traversal of the \gls{cst} is done, and how much of the \gls{cst} is visited. ANTLR can generate a visitor interface, this interface is created from Arcs grammar, and basevisitor abract class is also created it functions as a boilerplate for the a visitor implemementation.\cite{Parr2014}.

The arc implemementation makes use of the visitor pattern, because it provides flexibility in how each node is handled and allows for good scalebility. It is also the more extendable option because new kinds of nodes are chagenges to old nodes are handled in just one place each\todo{is this understandeble}. This is especially good for futureproofing, as there might be certain things that had not been predicted, and can therefore be specifically fixed.

An example of how Arc implements a visitor method, can be seen in figure \ref{lst:visitorterminalexpression}, this is the visitor method called when visiting a terminal expression node in the \gls{cst}. The method creates a string variable 'name' that is assigned to the value of the method \textbf{.getText} of the formal paramater 'ctx' . From this, an AST\_node variable 'terminal' is made. Then a series of checks are made, to find the type of terminal expression that is being visited, to give 'terminal' the correct type. The first check being, if the formal paramater 'ctx' contains a number, if it does, the type of the terminal is assigned to be NUM, which is Arcs representation of numbers. If it does not contain a number, the next check, which is for boolean, is made, after this the same type of check is made for characters. Then a check This is done mostly for debugging puposes so its easy to find out whats going on in a given node its not essential for thhe program in praksis. The idetifier is abit different then the rest because does a check in the symbol since It must check if it exist. A exemption is thrown if it does not exist. The important part is the assignment of the typing which is assigned to the ast_node based on if statements and in the case its an idetifier the type is found in the symbol table. When the ctx is caught in a check, and no error is thrown, the type of 'terminal' will be set, and the method returns 'terminal'.

\todo[inline]{The description of these functions has to be checked to ensure the understanding of them is correct.}

\begin{listing}[htb!]
    \begin{minted}{java}
        public AST_node visitTerminal_expression(arcv2Parser.Terminal_expressionContext ctx) {
        String name;
        name = ctx.getText();
        AST_node terminal = new Terminal_expression_node(name);
        if (ctx.NUMBER() != null)
            terminal.type = Types.NUM;
        else if (ctx.BOOL() != null)
            terminal.type = Types.BOOL;
        else if (ctx.CHAR() != null)
            terminal.type = Types.CHAR;
        else if (ctx.IDENTIFIER() != null) {
            SymbolHashTableEntry id = symbolTable.get(ctx.IDENTIFIER().getText());
            if(id == null){
                throw new RuntimeException("This variable has not been declared '" + ctx.IDENTIFIER().getText() + "'");
            }
            else{
                terminal.type = id.Type;
            }
        } else {
            throw new RuntimeException("problems with terminal expression");
        }
        return terminal;
        }
    \end{minted}
    \caption{Visiting a terminal expression}
    \label{lst:visitorterminalexpression}
\end{listing}


Another example of how the visitor is used, is seen with figure \ref{lst:visitorplusminusexpression}, that shows how the visitor handles plus and minus expressions. First an AST\_node variable is made, called 'plus\_minus\_node', then a check is made, to determine if the expression is a plus expression, or a minus expression. Depending on the expression type, the variable 'plus\_minus\_node' is set to be a new AST\_node for either plus or minus\question{Unsure if this is correct}. The result of visiting the expressions are assigned as the children of the aforementioned Astnode. An array is made, that contains the first child of the 'plus\_minus\_node' node, and it's right sibling. To ensure that the plus or minus expression is legal in Arc, a check is made on the entire array. THe types of these 2 nodes are essentially checked if they are numbers if yes then the plus node is okay and dherefore also assigned the type num. This node is then returned.

\begin{listing}[htb!]
    \begin{minted}{java}
    public AST_node visitPlus_minus_expression(arcv2Parser.Plus_minus_expressionContext ctx) {
        AST_node plus_minus_node;

        if (ctx.children.get(1).getText().toCharArray()[0] == '+')
            plus_minus_node = new AST_node("plus");
        else
            plus_minus_node = new AST_node("minus");
        plus_minus_node.child = visit(ctx.expression(0));
        plus_minus_node.child.MakeSiblings(visit(ctx.expression(1)));

        AST_node[] astnodearray = { plus_minus_node.child, plus_minus_node.child.rightSibling };
        if (Typecheck.Check(astnodearray, Types.NUM))
            plus_minus_node.type = Types.NUM;
        else {
            throw new Expression_type_exception("the plus/minus expression has bad typing");
        }
        return plus_minus_node;
    }
    \end{minted}
    \caption{Visiting a plus or minus expression}
    \label{lst:visitorplusminusexpression}
\end{listing}


% \begin{listing}
%     \begin{minted}{java}
        
%     \end{minted}
% \end{listing}

%Describe to types of visitors we have used
%Show ALOT of code examples


%Options
%pros and cons of both
%How is it used
%How do we use it


%Vi vil ikke altid ind i alle noder, fordi det ikke er nødvændigt
%Det er sikre valg, da vi kan være specifikke for hver node, hvis der er noget vi ikke har forudset
%Future proof
