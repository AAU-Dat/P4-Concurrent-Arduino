\section{Visitor pattern}\label{sec:visitorpattern}

This section goes into detail about working with the integrated visitor pattern that \gls{antlr} provides its users with. There are multiple ways of traversing the \gls{cst}, with the two most popular being the listener and the visitor classes. Running the \gls{antlr} tools without any extra flags, results in the listener class being chosen by default. The difference between the two is that the listener is called by the walker-object provided by ANTLR, whereas the visitor must be called explicitly in order to walk its children \cite{Parr2014}. The listener is great for creating a \gls{cst} in which all of the nodes gets visited and none are ignored. It is thus an automatic process. Therefore, we can do the tree walking ourselves by choosing the visitor class, rather than simply reacting to the tree walker by choosing the listener class.

The visitor design pattern is a way to traverse the \gls{cst} in such a way that allows us to add new operations to an existing structure without having to modify it. It makes it both fast and easy to scale classes and fulfills the open/closed principle, by allowing extension and no modification. The 'Visitor' interface and the abstract 'BaseVisitor' class created by \gls{antlr} is necessary for the visitor implementation.






The arc implemementation makes use of the visitor pattern, because it provides flexibility in how each node is handled and allows for good scalebility. It is also the more extendable option because new kinds of nodes are chagenges to old nodes are handled in just one place each\todo{is this understandeble}. This is especially good for futureproofing, as there might be certain things that had not been predicted, and can therefore be specifically fixed.

An example of how Arc implements a visitor method, can be seen in figure \ref{lst:visitorterminalexpression}, this is the visitor method called when visiting a terminal expression node in the \gls{cst}. The method creates a string variable 'name' that is assigned to the value of the method \textbf{.getText} of the formal paramater 'ctx' . From this, an AST\_node variable 'terminal' is made. Then a series of checks are made, to find the type of terminal expression that is being visited, to give 'terminal' the correct type. The first check being, if the formal paramater 'ctx' contains a number, if it does, the type of the terminal is assigned to be NUM, which is Arcs representation of numbers. If it does not contain a number, the next check, which is for boolean, is made, after this the same type of check is made for characters. Then a check This is done mostly for debugging puposes so its easy to find out whats going on in a given node its not essential for thhe program in praksis. The idetifier is abit different then the rest because does a check in the symbol since It must check if it exist. A exemption is thrown if it does not exist. The important part is the assignment of the typing which is assigned to the ast\_node based on if statements and in the case its an idetifier the type is found in the symbol table. When the ctx is caught in a check, and no error is thrown, the type of 'terminal' will be set, and the method returns 'terminal'.

\todo[inline]{The description of these functions has to be checked to ensure the understanding of them is correct.}

\begin{listing}[htb!]
    \begin{minted}{java}
        public AST_node visitTerminal_expression(arcv2Parser.Terminal_expressionContext ctx) {
        String name;
        name = ctx.getText();
        AST_node terminal = new Terminal_expression_node(name);
        if (ctx.NUMBER() != null)
            terminal.type = Types.NUM;
        else if (ctx.BOOL() != null)
            terminal.type = Types.BOOL;
        else if (ctx.CHAR() != null)
            terminal.type = Types.CHAR;
        else if (ctx.IDENTIFIER() != null) {
            SymbolHashTableEntry id = symbolTable.get(ctx.IDENTIFIER().getText());
            if(id == null){
                throw new RuntimeException("This variable has not been declared '" + ctx.IDENTIFIER().getText() + "'");
            }
            else{
                terminal.type = id.Type;
            }
        } else {
            throw new RuntimeException("problems with terminal expression");
        }
        return terminal;
        }
    \end{minted}
    \caption{Visiting a terminal expression}
    \label{lst:visitorterminalexpression}
\end{listing}


Another example of how the visitor is used, is seen with figure \ref{lst:visitorplusminusexpression}, that shows how the visitor handles plus and minus expressions. First an AST\_node variable is made, called 'plus\_minus\_node', then a check is made, to determine if the expression is a plus expression, or a minus expression. Depending on the expression type, the variable 'plus\_minus\_node' is set to be a new AST\_node for either plus or minus\question{Unsure if this is correct}. The result of visiting the expressions are assigned as the children of the aforementioned Astnode. An array is made, that contains the first child of the 'plus\_minus\_node' node, and it's right sibling. To ensure that the plus or minus expression is legal in Arc, a check is made on the entire array. THe types of these 2 nodes are essentially checked if they are numbers if yes then the plus node is okay and dherefore also assigned the type num. This node is then returned.

\begin{listing}[htb!]
    \begin{minted}{java}
    public AST_node visitPlus_minus_expression(arcv2Parser.Plus_minus_expressionContext ctx) {
        AST_node plus_minus_node;

        if (ctx.children.get(1).getText().toCharArray()[0] == '+')
            plus_minus_node = new AST_node("plus");
        else
            plus_minus_node = new AST_node("minus");
        plus_minus_node.child = visit(ctx.expression(0));
        plus_minus_node.child.MakeSiblings(visit(ctx.expression(1)));

        AST_node[] astnodearray = { plus_minus_node.child, plus_minus_node.child.rightSibling };
        if (Typecheck.Check(astnodearray, Types.NUM))
            plus_minus_node.type = Types.NUM;
        else {
            throw new Expression_type_exception("the plus/minus expression has bad typing");
        }
        return plus_minus_node;
    }
    \end{minted}
    \caption{Visiting a plus or minus expression}
    \label{lst:visitorplusminusexpression}
\end{listing}


% \begin{listing}
%     \begin{minted}{java}
        
%     \end{minted}
% \end{listing}

%Describe to types of visitors we have used
%Show ALOT of code examples


%Options
%pros and cons of both
%How is it used
%How do we use it


%Vi vil ikke altid ind i alle noder, fordi det ikke er nødvændigt
%Det er sikre valg, da vi kan være specifikke for hver node, hvis der er noget vi ikke har forudset
%Future proof
