\section{Visitor pattern}\label{sec:visitorpattern}\feedback{We still working on this section, and unsure what is missing}
This section will briefly discuss the two methods ANTLR provides of traversing a \gls{cst}, listeners and visitors, what they are, how they are used, and why they are used in Arc.

The listener pattern, is not responsible for calling methods to traverse the tree. ANTLR generates enter and exit methods for each rule, these methods are then called when the walker encounters a node. The benefits of using the listener pattern, is that it is automatic, and the methods created do not have to explicitly visit all their child nodes\cite{Parr2014}. \feedback{We are unsure of how correct this actually is, taken from: Page 18}

The visitor pattern, is a method used to traverse the \gls{cst} in a specific manner, where methods are used to visit each child node. By using the visitor pattern, there is more control of how the traversal of the \gls{cst} is done, and how much of the \gls{cst} is visited. ANTLR can generate a visitor interface, this interface is created from Arcs grammar, and creates all the needed visitor methods. These act as boilerplate for Arcs needed visitor methods, that can then be written out to do excatly as needed\cite{Parr2014}.

For Arc there is made use of the visitor pattern, because it is not neccecary, for Arc, to visit all nodes, since for some of them it is known what will follow. It is also the more secure option, as it gives the option to be more specific about what happens for each node. This is especially good for futureproofing, as there might be certain things that had not been predicted, and can therefore be specifically fixed.

An example of how Arc implements a visitor method, can be seen in figure \ref{lst:visitorterminalexpression}, this is the visitor method called when visiting a terminal expression node in the \gls{cst}. The method creates a string variable 'name' that is assigned to the value of the method \textbf{.getText} of the formal paramater 'ctx'. From this, an AST\_node variable 'terminal' is made. Then a series of checks are made, to find the type of terminal expression that is being visited, to give 'terminal' the correct type. The first check being, if the formal paramater 'ctx' contains a number, if it does, the type of the terminal is assigned to be NUM, which is Arcs representation of numbers. If it does not contain a number, the next check, which is for boolean, is made, after this the same type of check is made for characters. Then a check for the identifier is made, if it contains an identifer, a SymbolHashTableEntry variable 'id' is made based on the identifer of the variable 'ctx'. If the variable 'id' is null, this means that the variable has not been declared, and an error is thrown, informing the user. If not, then the type of the variable 'terminal' is assigned to the type of the variable 'id'. If ctx\question{maybe another name} does not get caught in any of the checks, it means there is an issue with the terminal that does not fall under any of the considered conditions. When the ctx is caught in a check, and no error is thrown, the type of 'terminal' will be set, and the method returns 'terminal'

\todo[inline]{The description of these functions has to be checked to ensure the understanding of them is correct.}

\begin{listing}[htb!]
    \begin{minted}{java}
        public AST_node visitTerminal_expression(arcv2Parser.Terminal_expressionContext ctx) {
        String name;
        name = ctx.getText();
        AST_node terminal = new Terminal_expression_node(name);
        if (ctx.NUMBER() != null)
            terminal.type = Types.NUM;
        else if (ctx.BOOL() != null)
            terminal.type = Types.BOOL;
        else if (ctx.CHAR() != null)
            terminal.type = Types.CHAR;
        else if (ctx.IDENTIFIER() != null) {
            SymbolHashTableEntry id = symbolTable.get(ctx.IDENTIFIER().getText());
            if(id == null){
                throw new RuntimeException("This variable has not been declared '" + ctx.IDENTIFIER().getText() + "'");
            }
            else{
                terminal.type = id.Type;
            }
        } else {
            throw new RuntimeException("problems with terminal expression");
        }
        return terminal;
        }
    \end{minted}
    \caption{Visiting a terminal expression}
    \label{lst:visitorterminalexpression}
\end{listing}


Another example of how the visitor is used, is seen with figure \ref{lst:visitorplusminusexpression}, that shows how the visitor handles plus and minus expressions. First an AST\_node variable is made, called 'plus\_minus\_node', then a check is made, to determine if the expression is a plus expression, or a minus expression. Depending on the expression type, the variable 'plus\_minus\_node' is set to be a new AST\_node for either plus or minus\question{Unsure if this is correct}. A child node is then assigned to be the first expression of the 'ctx', and a sibling to that child is assigned to the second expression of 'ctx'. With this, the expression has been structured in a way that resebels that of a tree.\question{Maybe just yeet that last part, or go more in depth} An array is made, that contains the first child of the 'plus\_minus\_node' node, and it's right sibling. To ensure that the plus or minus expression is legal in Arc, a check is made on the entire array. This check, makes a type check to ensure that all the child nodes and their siblings are numbers. If this this is true, the type of the 'plus\_minus\_node' node is set to be numer, if not an error is thrown, since Arc does not allow for the plus or minus expression to be used on anything but numbers. Is no error is thrown, the 'plus\_minus\_node' node is returned.

\begin{listing}[htb!]
    \begin{minted}{java}
    public AST_node visitPlus_minus_expression(arcv2Parser.Plus_minus_expressionContext ctx) {
        AST_node plus_minus_node;

        if (ctx.children.get(1).getText().toCharArray()[0] == '+')
            plus_minus_node = new AST_node("plus");
        else
            plus_minus_node = new AST_node("minus");
        plus_minus_node.child = visit(ctx.expression(0));
        plus_minus_node.child.MakeSiblings(visit(ctx.expression(1)));

        AST_node[] astnodearray = { plus_minus_node.child, plus_minus_node.child.rightSibling };
        if (Typecheck.Check(astnodearray, Types.NUM))
            plus_minus_node.type = Types.NUM;
        else {
            throw new Expression_type_exception("the plus/minus expression has bad typing");
        }
        return plus_minus_node;
    }
    \end{minted}
    \caption{Visiting a plus or minus expression}
    \label{lst:visitorplusminusexpression}
\end{listing}


% \begin{listing}
%     \begin{minted}{java}
        
%     \end{minted}
% \end{listing}

%Describe to types of visitors we have used
%Show ALOT of code examples


%Options
%pros and cons of both
%How is it used
%How do we use it


%Vi vil ikke altid ind i alle noder, fordi det ikke er nødvændigt
%Det er sikre valg, da vi kan være specifikke for hver node, hvis der er noget vi ikke har forudset
%Future proof
