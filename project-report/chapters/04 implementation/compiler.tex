\section{Compiler}\label{sec:compiler}
The purpose of a compiler is to convert source code into target code. In the case of the Arc compiler, the source code is text written in the Arc language. A generalized model of the compilation process can be seen in Figure~\ref{fig:generalcompilermodel}.

The target code is often low level code for a particular system or runtime, but not always. When the target code is another high level languange, the process is also called transpilation. The Arc languange is used for programming Arduinos, and so the compiler has to either generate Arduino specific machine code, or transpile to the high level Arduino language. Because the Arc language leverages the Protothreads library for the Arduino for its concurrency model, the Arc compiler is a transpiler.


\begin{figure}[htb!]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/Full_Compiler.png}
    \caption{A general model of a compiler~\cite{CraftingCompiler}}
    \label{fig:generalcompilermodel}
\end{figure}


The Arc compiler follows many of the steps of the general model. Figure~\ref{fig:arccompilermodel} models the Arc compiler, with some noteworthy details.

\begin{figure}[htb!]
    \centering
    

    \begin{tikzpicture}[node distance=3cm]


        \begin{scope}[node distance=3cm,local bounding box=clusterA]
            \node (a) [state] {Scanner} node[below,scale=.7, xshift=60,yshift=-20]{Antlr};
            \node (b) [state, right of=a] {Parser};
            \draw[arrow, ->] (a) -- node[above,scale=.70,align=center]{Tokens} (b);
        \end{scope}

        \node(clusterA_g)[cluster,fit=(clusterA)]{};
        \node (start) [shift={($(clusterA.west)+(-2cm,0)$)}] {Source code};
        \node (c) [state, right of = b] {Type checker};
        \node (d) [state, shift={($(c.south)+(0,-1.5cm)$)}] {Scope checker};
        \node (e) [state, shift={($(d.south)+(0,-1.5cm)$)}] {Code generator};
        \node (f) [shift={($(e.south)+(0,-1cm)$)}] {Target code};

        \draw[arrow, ->] (start) -- (clusterA_g);
        \draw[arrow, ->] (b) -- node[right,scale=.70,xshift=-10,yshift=7]{AST} (c);
        \draw[arrow, ->] (c) -- node[right,scale=.70,align=center]{AST} (d);
        \draw[arrow, ->] (d) -- node[right,scale=.70,align=center]{AST} (e);
        \draw[arrow, ->] (e) --  (f);

    \end{tikzpicture}
    \caption{The Arc compiler.}
    \label{fig:arccompilermodel}
\end{figure}

In figure \ref{fig:arccompilermodel}, the source code is first scanned into tokens and then parsed into an AST, Antlr handles all this, therefore the box around scanner and parser. The AST is then type checked. After type check, the code is then scope checked. the type and scope check rules can be read in section 3.4. After the code has been checked further. It is time to code generate the Arc code, into Arduino code. Which is the last step in the compiler. The code is then in Arduino code.  
