\section{Type checker}
This section will discuss the type checker for Arc, how it is structured and also show examples of how it works.

The type checker verifies that operands of an operator are of compatible types, and if not, throws an error, with an error message for the user to use to fix the issue \cite{Sebesta2016}. It does this by walking through the \gls{cst} from the bottom-up, with a visitor pattern \cite{Parr2014}. An example of the type checker throwing an error would be the case where a user tries to use the plus operand on a num and a char, this will throw an error to the user telling them, that this operation is not valid in Arc.

There are two ways to type check, static and dynamic type checking. Static type checking works on compile time, dynamic type checking is done during run time. Usually it is better to use static type checking, as it catches errors earlier compared to dynamic type checking, and is less costly \cite{Sebesta2016}. Altough dynamic typing allows for more flexablility when writing code, as in languages such as Python where types are not needed to be declared, but simply values are to be given.

In Arc there will be made use of a static type checker, this is because the language that Arc transpiles to is C++ which is a staticly typed language. For this reason it makes sense for Arc to also be a staticly typed language, so it can be easily used with the Arduino, which uses a language that is a subset of the C++ language. \todo{inds√¶t evt ref til at Arduino bruger C++} Combined with the previously mentioned benefits of using a staticly typed language, it seemed like the obviouse decision to have Arc be a staticly typed language. Although an argument could be made that Arc should be made a dynamicly typed language, since often dynamicly typed languages, such as Python, tend to be faster to write code in. Since time is a limiting factor for our definition of a hobbyist, it would make sense to make a language that encourages less time spent writing code. But since Arc is only made to work with simple concurrency, this time spent on writing code, might not give as much of a gain, as in a standard language. \todo{This just sounds like bullshit -gustav "true"}

\begin{listing}[htb!]
    \begin{minted}{java}
        SymbolHashTableEntry entry = symbolTable.get(ctx.IDENTIFIER().getText());
        

        //TODO  this needs to handle arrays (should we even allow array assignment)
        AST_node expression = visit(ctx.expression(0));

        if (entry == null) {
            throw new RuntimeException(" this varible '" + ctx.IDENTIFIER().getText() + "' does not exist");
        }
        else if (entry.Mutability != true) {
            throw new RuntimeException(" this varible '" + ctx.IDENTIFIER().getText() + "' is not mutable and therefore cannot be assigned to");
        }
        else if (entry.Type !=  expression.type) {
            throw new Expression_type_exception("the assingment expression has bad typing");
        }
        else{
            symbolTable.insert(entry);
        }
    \end{minted}
    \caption{Code snippet of Arcs type checker}
    \label{lst:typecheckerexample}
\end{listing}
\todo[inline]{Feel like it is missing a function name}
\todo{this is actually a bad example as it shows too much you talk about alot of checks that arent type check like scope cheks}
\ref{lst:typecheckerexample} shows am example of Arcs typechecker. This example shows the part of the typechecker, handles assignments. It does this by creating 'entry' of the class SymbolHashTableEntry and assigns it to the contents of a ctx file\tode{yeah, naw. thats not whats happening were creating an entry and assigning to it the result of a lookup in the symbolTable based on the IDENTIFIER that were assigning to.}. Then it creates 'expression' of the AST\_node class, and uses a visitor method to assign it to the first expression of the \gls{cst}\tode{this is closer. here were creating a ast nodes and assingning it the result of a visit to a expression. and in our visitor a visit always returns a ast node}. It is then evaluated in a sequence of if statements, to ensure that the assignment is a legal action in Arc. First checking if the entry even exists, then if the entry is mutable and finally checking if the types of the entry and expression are equvilant. If the entry passes all the checks, it is then inserted into the sybol table. If it does not pass one of the checks, an exeption is thrown and a relevant error message is given.
\todo[inline]{Entire paragraph has to be checked to ensure it is correct}


%dynamic vs static typechecking
%formal definitions som cagala?
%Why is it important to have a typechecker
%argument could be made that a dynamic typed language would be better for hobbyists since time is a limiting factor for them, and in general dynamicly typed languages are faster to write code in.