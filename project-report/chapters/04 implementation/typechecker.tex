\section{Type checker}\label{sec:typechecker}

This section will discuss the type checker for Arc, how it is structured and present an example of how it is implemented.

The type checker is responsible for verifying that operands on either side of an operator evaluates to a number value, and other compatibility checks on types. If another type than an expected legal type is found, then it throws an error along with a message for the developer to fix the issue \cite{Sebesta2016}. It does this by walking through the \gls{cst} from the bottom-up, with a visitor pattern \cite{Parr2014}. An example of a type checker throwing an error could be in case of a developer attempting to use the addition operator on a number and a character. This is going to throw an error in Arc, while it is unexpected behaviour we have not accounted for in the language.

As with scoping, there are two ways of doing type checking: statically and dynamically. Static type checking is done at compile time, while dynamic type checking is done at run time. Usually, it is considered a better practice to use static type checking, due to the fact that it catches any potential errors earlier compared to a dynamic type checker, and it cost less too \cite{Sebesta2016}. However, dynamic typing allows for more flexibility when writing code. An example of this can be seen in languages such as Python and JavaScript, in which variables does not need to have a type on declaration - all they need is a value. They can also change "type" if the developer chooses to assign a number to a variable containing a string.

The language Arc transpiles to is C++, which is a staticallly typed language. For this reason Arc will use a static type checker, to make the transpilation more one-to-one. Although, an argument could be made for Arc to use dynamic type checking, since dynamically typed languages often tend to be faster to write code in. Since time is a limiting factor for our target group, it would make sense to make a language that encourages less time spent on writing code. However, while Arc is only made to work with simple concurrency, time is better spend elsewhere.

% SHOULD WE FIND ANOTHER EXAMPLE?



\begin{listing}[htb!]
    \begin{minted}[label=Typechecking in SemanticVisitor.visitAssignmentStatement]{java}
        SymbolHashTableEntry entry = symbolTable.get(ctx.IDENTIFIER().getText());
        AST_node expression = visit(ctx.expression(0));

        if (entry == null) {
            throw new RuntimeException(" this varible '" + ctx.IDENTIFIER().getText() + "' does not exist");
        } else if (entry.Mutability != true) {
            throw new RuntimeException(" this varible '" + ctx.IDENTIFIER().getText() + "' is not mutable and therefore cannot be assigned to");
        } else if (entry.Type != expression.type) {
            throw new Expression_type_exception("the assingment expression has bad typing");
        } else{
            symbolTable.insert(entry);
        }
    \end{minted}
    \caption{Code snippet of type checking in Arc.}
    \label{lst:typecheckerexample}
\end{listing}

%\todo{this is actually a bad example as it shows too much you talk about alot of checks that arent type check like scope cheks}

%\ref{lst:typecheckerexample} shows am example of Arcs typechecker. This example shows the part of the typechecker, handles assignments. It does this by creating 'entry' of the class SymbolHashTableEntry and assigns it to the contents of a ctx file\todo{yeah, naw. thats not whats happening were creating an entry and assigning to it the result of a lookup in the symbolTable based on the IDENTIFIER that were assigning to.}. Then it creates 'expression' of the AST\_node class, and uses a visitor method to assign it to the first expression of the \gls{cst}\todo{this is closer. here were creating a ast nodes and assingning it the result of a visit to a expression. and in our visitor a visit always returns a ast node}. It is then evaluated in a sequence of if statements, to ensure that the assignment is a legal action in Arc. First checking if the entry even exists, then if the entry is mutable and finally checking if the types of the entry and expression are equvilant. If the entry passes all the checks, it is then inserted into the sybol table. If it does not pass one of the checks, an exeption is thrown and a relevant error message is given.

Listing~\ref{lst:typecheckerexample} shows an example of Arcs typechecker. This example shows the part of the typechecker, handles assignments. First an 'entry' of the class SymbolHashTableEntry is made, this 'entry' is assigned to the result of a lookup in the symbolTable based on the IDENTIFIER. Then the expression of that node is made, we call this variable 'expression' and is the class \gls{ast}\_node. 'Expression' is made by visiting the expression of the ctx node, and with Arcs visitor, it always returns an \gls{ast} node.

After creating these variables, some typechecking can be done, this is specifically type checking for assignemnts of variables. The first check, that ensure that the entry actually exists, is not actually type checking, but rather a part of scope handling. The next check, ensure that the entry that is being assigned to, is actually mutable, meaning that it can be modified, if not an error is thrown, that informs the user that they are trying to assing to an immutable variable. After this a check is made to ensure that the entry that is being assigned to, and the expressions typing actually match and are compatible for assignment. If this check fails, an error message informing users that the assignment has bad typing is made.

After these checks have all passed, typechecking for the assignment is complete, and the 'entry' is added to the symbol table.