\section{Code Generation}

how is it done? through visitor pattern and antlr generated ast


This section will explain the code gen part of the compiler. In this part the target
code is generated. The target code is in this case the arduino languege is essentially c++ with some arduino constructs. The Code is generated using another visitor pattern quite simelar to the one we use for semantic analysis. It follows the divide and conquer principle and uses the antlr genrerated ast. It then genrates the code going through the ast and passing the generated code between the nodes using our CodeGenStringObject.

\begin{listing}[htb!]
    \begin{minted}{java}
        public class CodeGenStringObject {
            public String GlobalScope = "";
    public String Setup = "";
    public String Loop = "";

    public String Type_Coverter (String input){
        
        if(input.equals("mut num") || input.equals("num" )){
            input = "float";
        }
        
        if(input.equals("mut char")){
            input = "char";
        }

        if(input.equals("mut bool")){
            input = "bool";
        }
        
        return input;
    }
    
}
\end{minted}
\caption{code gen object used in code gen}
\label{lst:code gen object}
\end{listing}

we use the CodeGenStringObject because a node sometimes will generate code in 3 different places of the final code at once. Hence we have a made a object containing 3 different strings and a method. The 3 string each corespond one of the 3 areas that can be generated to, GlobalScope, the Setup structure and the loop structure. This makes it possible to do all code gen simply in a single visit of the 3 beacuse its not necessary to keep track of 3 different placements in the file and switch between writing in them. The final code gen is done by using the final CodeGenStringObject and simply inserting the 3 strings into the file in order. \todo{this needs to be more clear and use an example to show it} The method in CodeGenStringObject is simply used in code gen to rewrite the types that we have in the input to the corresponding types in c++.

The visitor pattern is very similar to the one used for type checking scope schecking etc beacause theyre all extentions of the arcv2basevisitor. This is possible because theyre using the same Antlr generated Ast as input. The reason a custom ast is not created is because it wold look very similar to the one Antlr would generate because our grammar generally creates a quite shallow tree so the ast would not be very different in structure. It would also make it necessary to do alot of reimplementing alot of methods and datastructures that antlr ast has baked in. Therefore we keep using the antlr AST since there isnt alot of upside to making a new one. \todo{does this sound convinsing?} 


In figure \ref{lst:codegenexpression} we see a simple example of how The code gen visitor works. Here we see it first creates 2 object of the class CodeGenStringObject shown earlier. One is named cpp, which stands for c + +, and one named temp since its temporary and does not get returned out of method. Then we assign temp the result, the globalscope of this object is then added to cpp. Only the gloabal scope is added since we know only different expression can exist within expression and none of our expressions add to anything other than global scope. Then we use the result of ctx.Plus to check if we should add a plus or minus to cpp. Ctx.Plus either a plus terminal or null if it doesnt exist hence this is possible. At the end we do the same thing again with the visit just with the second expression which is then added to cpp and cpp is returned to this nodes parent. We dont check if more exist because only 2 can exist in a plus minus ctx. So basicly this visitor visits a node adds the result of visiting its children to it and then returns it to its own parent, which is essentially how we codegen.




initial example 
\begin{listing}[htb!]
    \begin{minted}{java}
    public CodeGenStringObject visitPlus_minus_expression(arcv2Parser.Plus_minus_expressionContext ctx) {
        CodeGenStringObject cpp = new CodeGenStringObject();
        CodeGenStringObject temp = new CodeGenStringObject();

        temp = visit(ctx.expression(0));
        cpp.GlobalScope += temp.GlobalScope + " ";

        if (ctx.PLUS() != null) {
            cpp.GlobalScope += "+ ";
        } else {
            cpp.GlobalScope += "- ";
        }

        temp = visit(ctx.expression(1));
        cpp.GlobalScope += temp.GlobalScope;

        return cpp;
    }
\end{minted}
\caption{code gen object used in code gen}
\label{lst:codegenexpression}
\end{listing}


A different intresting part of the code gen visitor is the task declaration visit which is visible here\ref{codeGenTask}. 
This one has abit more happening. The first part until line??? descripes the creation of the cpp CodeGenStringObject and all the things that should be added to the global scope every time a task is declared. It also Creates a name for the thread which will be used in c++, this is necessary because the tasks in arc do not have names. These names are generated generically based on a counter function which can be seen at the button so they end op being named pt0thread, pt1thread etc..
That means all the things needs to be inserted to create a protothread. Afterwards we see 3 control structures an if, else if and an else which descripe the 3 different ways we describe a task.

Firstly on line?? we have a if statement that similarly to the previous example checks if there is a every and if there is we enter the if statement. Inside First that happens is the creation of a list of all the statements that are the immediate children of task declaration. This list is then itterated through and the result of the visits to the individual children are added to the cpp in order. This if Finishes with adding what is essentially a call to a protothreads function sleep that sleeps the thread for the amount of time specified in the Number which corresponds only to every because it only exist if there is a every.

Second is the case where we use a when in taht case we add a if statement inside of the protothread and inserting product of a visit to the bolean expression that we know have to exist if there is a when per our grammar. On line?? we again see the construct used to add the statements.  

The Third else case is just the same statement iteration without anything extra. 


how it works with example
    -tasks
    \begin{listing}[htb!]
        \begin{minted}{java}
    @Override
    public CodeGenStringObject visitTask_declaration(arcv2Parser.Task_declarationContext ctx) {
        CodeGenStringObject cpp = new CodeGenStringObject();

        String ptName = "pt" + Integer.toString(get_task_number());
        String ptNameThread = ptName + "thread";

        cpp.GlobalScope += "pt " + ptName;
        cpp.GlobalScope += ";\n";
        cpp.GlobalScope += "int " + ptNameThread + "(struct pt *pt) { \n PT_BEGIN(pt);\n for(;;){ \n";

        // region Every

        if (ctx.EVERY() != null) {
            List<StatementContext> list = ctx.statement();
            for (StatementContext statement : list) {
                cpp.GlobalScope += visit(statement).GlobalScope;
            }
            cpp.GlobalScope += "\nPT_SLEEP(pt, " + ctx.NUMBER().getText() + ");\n";
            cpp.GlobalScope += "\n}\n";
        }

        // endregion

        // region When

        else if (ctx.WHEN() != null) {
            cpp.GlobalScope += "if (" + visit(ctx.expression()).GlobalScope + ") { \n";

            List<StatementContext> list = ctx.statement();
            for (StatementContext statement : list) {
                cpp.GlobalScope += visit(statement).GlobalScope;
            }
            cpp.GlobalScope += "\n}\n";
        }

        // endregion

        // region Default

        else {
            List<StatementContext> list = ctx.statement();
            for (StatementContext statement : list) {
                cpp.GlobalScope += visit(statement).GlobalScope;
            }
            cpp.GlobalScope += "\n}\n";
        }

        // endregion

        cpp.GlobalScope += "PT_END(pt);\n}";

        cpp.Setup += "PT_INIT(&" + ptName + ");";
        cpp.Loop += "PT_SCHEDULE(" + ptNameThread + "(&" + ptName + "));";

        return cpp;
    }

    private int count = 0;

    public int get_task_number() {
        int temp = count;
        count += 1;
        return temp;
    }

    }
        \end{minted}
        \caption{code showing how task are generated}
        \label{lst:codeGenTask}
    \end{listing}


