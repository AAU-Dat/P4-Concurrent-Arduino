\section{Scoping}\label{sec:scoping}

Scoping is a description of when and where a variable is visible, can be referenced or assigned a value. It is an important part of any programming language. Identifiers are often reused - some even commonly, such as the iterator 'i' used in loop constructs or 'temp' for temporary local variables and so on. Scoping is very useful for handling the different layers of a code. We typically distinguish between two types of scoping: dynamic and static.

Static scoping, as the name implies, means that the scope of variables are determined statically, before the execution of a program. Static scoping is used by many languages, including C and C\#. Static scoping is said to be more readable, since the code often directly shows the value of a variable. When a reference to a variable is found and we want to know the value, we can follow the variable from its initialisation and look at any changes to the value of the variable in previous references. This means that the compiler first looks for the variable in the current block, then the global variables, and then in smaller scopes.

Dynamic scoping, on the contrary, means that the scope of variables is determined at run time. Dynamic scoping, albeit not as popular, is used in languages such as Perl and Common Lisp. Dynamic scoping works by using the calling sequence of subprograms to determine the value of a variable. It is said to decrease readability while it can be difficult to know exactly which calling sequences of subprograms contains a reference to a variable \cite{Sebesta2016}. This means that the compiler first looks in the current block; but then it moves on to each successive calling function in reverse. An example of the difference between static and dynamic scoping can be seen in Listing \ref{lst:scopeexample}.

\begin{listing}[htb!]
    \begin{minted}{C}
        int a;

        void main()
        {
            a = 10;
            f();
        }

        void f()
        {
            int a = 20;
            g();
        }

        void g()
        {
            print (a);
        }

        // static scope, prints: 10
        // dynamic scope, prints: 20
    \end{minted}
    \caption{An example of how static and dynamic scoping differs.}
    \label{lst:scopeexample}
\end{listing}

If the code snippet uses static scoping, the print method is going to print '10'. While the variable 'a' is not available in the scope of function 'g', the compiler is going to look in the global scope and find a variable 'a' there. In the 'main' function the variable 'a' is assigned the value of 10. In function 'f' another varibale 'a' is instantiated and immediately assigned the value of 20, however, 'a' in this function refers to the local variable and has nothing to do with the global 'a'. If the code snippet uses dynamic scoping, the print method is going to print '20'. Instead of looking at the global variables, the compiler goes back to the calling function 'g' and looks for a variable 'a', which it finds and then prints as the result.

Arc uses static scoping because of it being more readable and easier to understand. C++ uses a variant of static scoping, which also makes it more reasonable for Arc to use a similar scope.

The implementation of different scopes is primarily handled by the block structure in our syntax. We push and pop the stack of scopes upon visitation. This can be seen in Listing {lst:VisitBlock}. The visitor begins by pushing the scope onto the stack in \textbf{line 2}, then it goes on to visit its children before popping the scope in \textbf{line 9}, when it is no longer needed.

\begin{listing}[htb!]
    \begin{minted}{java}
    public AST_node visitBlock(arcv2Parser.BlockContext ctx) {
        symbolTable.push();
        AST_node block = new Variable_declaration_node("block");
        List<arcv2Parser.StatementContext> list = ctx.statement();

        for (arcv2Parser.StatementContext statementContext : list) {
        visit(statementContext);   
        }
        symbolTable.pop();

        return block;
    }
    \end{minted}
    \caption{VisitBlock from our visitor.}
    \label{lst:VisitBlock}
\end{listing}

The scoping rules of Arc is implemented everywhere in our semantic visitor. An example of this can be seen in Listing \ref{lst:ScopeImplementationExample}. When the visitor reaches a for-loop, it makes a call to the symbolTable to check for the identifier given as input and find out if it has been declared properly. The get function returns null if it does not exist, therefore, we check if the 'entry' identifier is null before continuing.

\begin{listing}[htb!]
    \begin{minted}{java}
    @Override public AST_node visitForloop_statement(arcv2Parser.Forloop_statementContext ctx) { 
        ...
        SymbolHashTableEntry entry = symbolTable.get(ctx.IDENTIFIER(1).getText());
        if (entry == null) {
            throw new RuntimeErrorException(null, "this identifier '" + ctx.IDENTIFIER(1).getText() + "' does not exist" );
        }
        ...
    }
    \end{minted}
    \caption{The SymbolHashTableEntry class}
    \label{lst:ScopeImplementationExample}
\end{listing}