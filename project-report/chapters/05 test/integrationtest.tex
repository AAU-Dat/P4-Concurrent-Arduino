\section{Integration test}\label{subsec:integrationtest}

% https://dzone.com/articles/integration-testing-what-it-is-and-how-to-do-it-ri#:~:text=What%20Is%20System%20Integration%20Testing,together%20into%20a%20complete%20system

An integration test is a test method that tests how well components and units interact with each other; To make sure that each of the components or units can interact without any errors or bugs. When creating an integration test, you can follow some famous formats to ensure that the integration test follows the same format and ensure the test's qualitative is high enough. Some of the forms are:

\begin{enumerate}
    \item Big Bang Approached
    \item Incremental Approached
    \item Bottom-up Integration
    \item Top-down Integration
    \item Hybrid/Sandwhich Integration
\end{enumerate}

The form that would fit best in our implementation compared to how we have created our implementation part in the report would be the Big Bang Approach. The Big Bang Approach is one of the most used structures in an integration test, where the purpose of this test structure is to group all of the components and unit tests and test them all at once. In our case, this fits perfectly, as we would like to try if some specific source code can be transpile to a particular target code as C++. Moreover, check if the transpile code is semantic equivalent to the source code. A disadvantage of using the Big Bang Approach is that if an error occurs or a bug makes the program fail, it is hard to determine which components or units are to blame for the mistakes [ref: to link].

So for this project, we could choose to test the lexer and parser to check if we get the correct syntax and token generated from a specific source code. However, as this part is already thoroughly tested by ANTLR, we can certainly assume that this park works as intended. It would make more sense for us to try the compiler as a whole unit to check whether or not we get the correct output code we expect to get. The code we want to test can be seen at [ref: arc code].

% Test the compiler as whole, and if the target code is the same as the inputted code? Check if its equivalent in the semantic meaning.
    % Give some input code
    % Get some output code in the target language
    % Is the shit semantic equivalent?


% Arc code example
\begin{listing}[htb!]
    \begin{minted}[label=Arc code example]{java}
        mut num buttonState = 0;
        mut num switch = 0;
        #pin BUTTON_PIN(12, INPUT);
        #pin LED1_PIN(10, OUTPUT);
        #pin LED2_PIN(11, OUTPUT);

        task(num switch) every 1000 {
            if(switch == 0){
                digitalWrite(LED1_PIN, HIGH);
                switch = 1;
            } else {
                digitalWrite(LED1_PIN, LOW);
                switch = 0;
            }
        }

        num blinkLED(num buttonState){
            if(buttonState == 1){
                digitalWrite(LED2_PIN, HIGH);
            } else {
                digitalWrite(LED2_PIN, LOW);
            }
        }

        task(num buttonState) {
            buttonState = digitalRead(BUTTON_PIN);
            blinkLED(buttonState);
        }
    \end{minted}
    \caption{Arc code example}
    \label{lst:arc code example}
\end{listing}

When compiling the code from the Arc example, we want to check after the output code in our target language has the exact semantic equivalent. We do this by manually looking through the new transpile code and going through each line of code to see if it does the same as the source code. As you can see in the transpile code at [ref: transpile code], both of the codes have the exact equivalent semantics, and therefore we can say that the test of the compiler as a whole work as intended.

% C++ Generated code from Arc code example
\begin{listing}[htb!]
    \begin{minted}[label=Generated C++ code from Arc code example]{java}
        #include "protothreads.h"
        float _buttonState = 0;
        float _switch = 0;
        #define _BUTTON_PIN 12
        #define _LED1_PIN 10
        #define _LED2_PIN 11
        pt pt0;
        int pt0thread(struct pt *pt){
            PT_BEGIN(pt);
            for (;;)
            {
                if (_switch == 0)
                {
                    digitalWrite(_LED1_PIN, HIGH);
                    _switch = 1;
                }
                else
                {
                    digitalWrite(_LED1_PIN, LOW);
                    _switch = 0;
                }
                PT_SLEEP(pt, 1000);
            }
            PT_END(pt);
        }
        float _blinkLED(float _buttonState){
            if (_buttonState == 1)
            {
                digitalWrite(_LED2_PIN, HIGH);
            }
            else
            {
                digitalWrite(_LED2_PIN, LOW);
            }
        }
        pt pt1;
        int pt1thread(struct pt *pt){
            PT_BEGIN(pt);
            for (;;)
            {
                _buttonState = digitalRead(_BUTTON_PIN);
                _blinkLED(_buttonState);
                PT_YIELD(pt);
            }
            PT_END(pt);
        }

        void setup(){
            Serial.begin(9600);
            pinMode(_BUTTON_PIN, INPUT);
            pinMode(_LED1_PIN, OUTPUT);
            pinMode(_LED2_PIN, OUTPUT);
            PT_INIT(&pt0);
            PT_INIT(&pt1);
        }

        void loop(){
            PT_SCHEDULE(pt0thread(&pt0));
            PT_SCHEDULE(pt1thread(&pt1));
        }
    \end{minted}
    \caption{Generated C++ code from Arc code example}
    \label{lst:generated C++ code from Arc code example}
\end{listing}