\section{Integration test}\label{subsec:integrationtest}
\begin{listing}[htb!]
    \begin{minted}[label=Arc code example]{text}
        mut num buttonState = 0;
        mut num switch = 0;
        #pin BUTTON_PIN(12, INPUT);
        #pin LED1_PIN(10, OUTPUT);
        #pin LED2_PIN(11, OUTPUT);
        task(num switch) every 1000 {
            if(switch == 0){
                digitalWrite(LED1_PIN, HIGH);
                switch = 1;
            } else {
                digitalWrite(LED1_PIN, LOW);
                switch = 0;
            }
        }
        num blinkLED(num buttonState){
            if(buttonState == 1){
                digitalWrite(LED2_PIN, HIGH);
            } else {
                digitalWrite(LED2_PIN, LOW);
            }
        }
        task(num buttonState) {
            buttonState = digitalRead(BUTTON_PIN);
            blinkLED(buttonState);
        }
    \end{minted}
    \caption{Arc code example}
    \label{lst:arc code example}
\end{listing}


This section presents the strategy for the integration test of the Arc compiler. The purpose of the integration test is to ensure that the different parts of the compiler work together in unison. Unlike unit tests, this includes the lexer and the parser generated by \gls{antlr}.

To this end, integration tests use Arc source code as input and assert on the output. In the tests, we assume that each unit works correctly, and a failing test means either a faulty test or a misuse of the integrated units. This assumption means that tests follow two patterns. The first pattern is input code that is syntactically and semantically correct that produces an output file. The second pattern is syntactically or semantically incorrect input that results in an error.


\begin{listing}[htb!]
    \begin{minted}[label=Generated C++ code from Arc code example]{arduino}
        #include "protothreads.h"
        float _buttonState = 0;
        float _switch = 0;
        #define _BUTTON_PIN 12
        #define _LED1_PIN 10
        #define _LED2_PIN 11
        pt pt0;
        int pt0thread(struct pt *pt){
            PT_BEGIN(pt);
            for (;;) {
                if (_switch == 0) {
                    digitalWrite(_LED1_PIN, HIGH);
                    _switch = 1;
                }
                else {
                    digitalWrite(_LED1_PIN, LOW);
                    _switch = 0;
                }
                PT_SLEEP(pt, 1000);
            }
            PT_END(pt);
        }
        ...//blink function definition omitted
        pt pt1;
        int pt1thread(struct pt *pt){
            PT_BEGIN(pt);
            for (;;){
                _buttonState = digitalRead(_BUTTON_PIN);
                _blinkLED(_buttonState);
                PT_YIELD(pt);
            }
            PT_END(pt);
        }
        void setup(){
            Serial.begin(9600);
            pinMode(_BUTTON_PIN, INPUT);
            pinMode(_LED1_PIN, OUTPUT);
            pinMode(_LED2_PIN, OUTPUT);
            PT_INIT(&pt0);
            PT_INIT(&pt1);
        }
        void loop(){
            PT_SCHEDULE(pt0thread(&pt0));
            PT_SCHEDULE(pt1thread(&pt1));
        }
    \end{minted}
    \caption{Generated arduino code from Arc code example}
    \label{lst:generated C++ code from Arc code example}
\end{listing}


To illustrate the first pattern, Listing~\ref{lst:arc code example} contains a variation of the sample project presented in section~\ref{sec:existingsolutions}, where a blinking function replaces the print function. This code compiles to the code from Listing~\ref{lst:generated C++ code from Arc code example} (formatted for readability), which is semantically equivalent to the source code. This equivalence is relatively easy to demonstrate because it resembles the sample project.
