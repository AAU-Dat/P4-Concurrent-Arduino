\section{Integration test}\label{subsec:integrationtest}

% https://dzone.com/articles/integration-testing-what-it-is-and-how-to-do-it-ri#:~:text=What%20Is%20System%20Integration%20Testing,together%20into%20a%20complete%20system

In this section the integration test will be describe as a hypothetical test, due to the timeframe within the scope of this semester. This means that the integration test will be described as how we intended to create integration test.

Integration test is a test method, which test how well components and units test intereact with eacher other; To make sure that each of the components or units can intergrate with each other without any errors or bugs. When creating integration test there are some popular structures you can follow to make sure that the integration test follows the same structure and to make sure the qualitative of the test is high enough. Some of the structures that can be followed is:

\begin{enumerate}
    \item Big Bang Approached
    \item Incremental Approached
    \item Bottom-up Integration
    \item Top-down Integration
    \item Hybrid/Sandwhich Integration
\end{enumerate}

The structure that would fit best in our implementation compared to how we have created our implementation part in the report would be the Big Bang Approach. The Big Bang Approach is one of the most used structures in integration test, where the purpose of this test structure is to group all of the components and unit test and test it all at once. In our case this fits perfectly, as we would like to test if some specific source code can be transpilet to a specific target code as C++. And to check if the transpilet code is semantic equivalent to the source code. A disadvantage of using Big Bang Approach is if an error occour or a bug makes the program fail, it is hard to figure out which components or unit that is to blame for the errors [ref: to link].

So for this project, we could chose to test the lexer and parser to check if we get the corect syntax and toksen generated from a specific source code. But, as this part is already throughly tested by ANTLR, we can with certianty assume that this park work as intended. It would make more sense for us to test the compiler as a whole unit, to check wether or not we get the correct output code as we expect to get.

% Test the compiler as whole, and if the target code is the same as the inputted code? Check if its equivalent in the semantic meaning.
    % Give some input code
    % Get some output code in the target language
    % Is the shit semantic equivalent?


% Arc code example
\begin{listing}[htb!]
    \begin{minted}[label=Arc code example]{java}
    num buttonState = 0;
    mut num switch = 0;
    #pin BUTTON_PIN(12, INPUT);
    #pin LED_PIN(11, OUTPUT);

    task(num switch) every 1000 {
        if(switch == 0){
            digitalWrite(led_builtin, HIGH);
            switch = 1;
        } else {
            digitalWrite(led_builtin, LOW);
            switch = 0;
        }
    }

    num blinkLED(num buttonState){
        if(buttonState == 1){
            digitalWrite(LED_PIN, HIGH);
        } else {
            digitalWrite(LED_PIN, LOW);
        }
    }

    task() {
        buttonState = digitalRead(BUTTON_PIN);
        blinkLED();
    }
    \end{minted}
    \caption{Arc code example}
    \label{lst:arc code example}
\end{listing}


% C++ Generated code from Arc code example
\begin{listing}[htb!]
    \begin{minted}[label=Generated C++ code from Arc code example]{java}

    \end{minted}
    \caption{Generated C++ code from Arc code example}
    \label{lst:generated C++ code from Arc code example}
\end{listing}