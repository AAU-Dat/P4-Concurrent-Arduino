\section{Usability Test of Arc}\label{subsec:usabilityTestOfArc}

A usability test is a valuable tool for projects to identify usability challenges and collect both quantitative- and qualitative data which can be used to conclusions aobut the Arc Language
determine the overall user satisfaction with the project's product.

A usability test on the Arc language would help determine how Arc compares to existing libraries and languages when handling concurrency on an Arduino. Therefore, Arc would be evaluated on its ability to handle concurrency and the writability of the language rather than how fast it executes, its memory usages, or other performance-related metrics.

\subsection{Aim of the test}\label{subsubsec:aimOfTheTest}

The usability test aims to determine how the Arc language measures up to our preformed expectations, as seen in [ref: table 3.2]. Arc would be evaluated by the Language Evaluation Criteria, as seen in [ref: table 3.1]. The focus of this project has been chiefly on simplicity and syntax design rather than support for abstraction. However, this test will still cover all of the characteristics to ensure that Arc lives up to the expectations and is easy to use for hobbyist developers. We have arranged the characteristics in [ref: table 3.2] in such a way that it should make it easier to use concurrency on an Arduino.

We have prepared a set of four questions that we would have wanted to get answered by the results of this test. These four questions are as follows:

\begin{enumerate}
    \item How easy is it to get familiar with and use Arc?
    \item What does a beggining programmer think of Arc?
    \item What does a more experienced programmer think of Arc and how does it compare to other programming languages?
    \item How would an evaluation of Arc based on the Language Evaluation Criteria by the experienced developer look?
\end{enumerate}

\subsection{The test participants}\label{subsubsec:theTestParticipants}

For this usability test, we would need participants with varied programming experience. We would need to divide them into two main groups: novice- and experienced programmers. The novice programmer would be needed to indicate how easy beginning programmers might find the Arc language to understand and use. In contrast, the experienced programmer would be able to provide us with a new perspective on our language and evaluate it based on their personal experience, and give a more constructive opinion on the language. The data collected from both the novice- and experienced programmers would help indicate how easy the language is to understand and use. In the scenario we were to conduct the test, we would also have to account for the distinction between a novice- and an experienced programmer - in case we had an intermediate programmer who has too much experience to be a novice but too little experience to be considered an experienced programmer. However, as this is only hypothetical, we will make do with our two categories for now.

By having the experienced programmers evaluate our language using the Language Evaluation Criteria, we could compare their results to our evaluation and check whether or not they agreed with our assessment.

It is typically best to have as many participants as possible for a usability test to provide the best possible results. However, we would only need a handful of participants in each group to have satisfactory results for this test.

\subsection{The test session}\label{subsubsec:theTestSession}

Each test participant would have a similar-looking individual test session - perhaps with different questions prepared for each group to better reflect their programming experience. For example, while it makes little sense to ask the novice programmer to evaluate the language using the Language Evaluation Criteria, it would be a missed opportunity not to ask that of the experienced programmer.

The test would be fully documented and recorded to capture the participant's reactions and actions during the test if the participant approves and allows us to record that is. A designated test moderator would then instruct the participant on how to complete the test while being impartial and trying not to influence the test results in any way and, in any case, as little as possible. The test moderator would also have to inform the participant to think aloud during the test to provide more data about their thought process while completing the tasks from the task list. This would help us evaluate the results and better distinguish the severity of any potential problems. The test would also be supervised by at least one other observer responsible for taking notes during the test.

Once the test is completed, the moderator would have a set of prepared questions to help the participant evaluate the Arc language. A set of questions for the novice programmers could look like this:

\begin{enumerate}
    \item How would you rate the Arc language as a beginner friendly programming language?
    \item How does it compare to any other programming language you might know of?
    \item How easy did you find the task function to work with when constructing new threads?
    \item Would you recommend other developers to use Arc, why or why not?
\end{enumerate}

While a set of questions prepared for the experienced programmers could look like this:

\begin{enumerate}
    \item How did the Arc language compare to your first programming language, with focus on simplicity?
    \item How does it compare to any other programming languages you have used in the past?
    \item Do you have any prior experience with concurrency and/or the Arduino?
    \item How would you evaluate the Arc language based on these Language Evaluation Criteria?
\end{enumerate}

\subsection{Task list}\label{subsubsec:taskList}

We have prepared a set of imaginary tasks to present our thought process as to how we would have approached designing the tasks for the participants. Each task would have to be solved by the participant with as little help from the moderator. First and foremost, we would have to test the readability and writability of the language. One way to do this would be to have them read some performed tasks such as tasks that:

\begin{enumerate}
    \item Toggles an LED on and off every second.
    \item Toggles an LED on and off when a condition has been met, such as a button press.
    \item Reads the state of a button as often as it can, unconditionally and without a sense of time.
\end{enumerate}

The idea is then for the participant to explain what is going on in each task using their own words and as little or as much terminology as they are comfortable with. The purpose is to test how easily they understand what happens in the code. After seeing some examples of the tasks, they would be tasked to create their tasks using Arc. They would have to create the same tasks they had already seen or at least similar tasks. The purpose is to test how intuitively and easy the code is to write.

\subsection{Analysis of the data}\label{subsubsec:analysisOfTheData}

After conducting all of the tests, we would have to analyze all the gathered data and compare the results. The first natural thing to do would be to go over the notes made by the test observer and the recorded material. For example, if one of the participants was stuck during a task - it could indicate that the participant had an issue with something; but if a multitude of the participants had a similar issue - it would indicate that something might be innately wrong with either the language or the task itself.

The next step would be to go over the findings made from observing the participants familiarising themselves with and working with the language. It would be the first time both the novice- and experienced programmers see the language, and while a learning curve can be expected with all new things, a certain margin of error is to be expected with all of the results due to this. However, it would also be interesting to see how much of a difference between the two groups when it comes to the ease of learning the Arc language and how well and fast they would be to complete their designated tasks. If the time difference between the two groups is insignificant, that might imply the language is easy to understand. More interestingly, in our effort to simplify and make our language easy to use for beginners, we might learn that we have made it more difficult for users with more programming experience to intuitively write the code and understand why we have done as we have. This would be reflected by results that indicate that novice programmers are faster at completing the tasks than experienced programmers. Any time comparisons would also acknowledge that one programmer could have received much help to complete a task while another could have received no help, which does not reflect the complete result.

The final thing to analyze would be the individual replies to the prepared questions after the test had concluded. It would be interesting to see how different the answers to the shared questions are and how the respondents answer the individual questions for their specific group. Perhaps, most interestingly would be to compare the experienced programmers' evaluations of the language to that of our own, using the Language Evaluation Criteria.