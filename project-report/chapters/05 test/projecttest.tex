\section{Usability Test of Arc}\label{subsec:usabilityTestOfArc}

Unfortunately, we did not have the time to conduct a real usability test within the allocated time of this semester; but we did manage to do the preparatory work needed for one. Therefore, the aim of this section is to describe the usability test in a hypothetical manner, and detail how we intended to integrate and make use of the test in the project.

A usability test is a useful tool for projects to identify usability challenges and collect both quantitative- and qualitative data to help determine the overall user satisfaction with the product of the project.

A usability test on the Arc language would be useful for determining how Arc compares to already existing libraries and languages when handling concurrency on an Arduino. Therefore, Arc would be evaluated on its ability to handle concurrency and the writability of the language, rather than how fast it executes, its memory usages, or other performance-related metrics.

% In this section, the usability test of Arc will be described as a hypothetic test. However, as there was not enough time to conduct the test within the timeframe of this semester, this section will only describe how the test was intended to be conducted.

% Before continuing, we will shortly mention what a usability test is and which results can be expected from conducting a usability test. A usability test is a tool that programmers use to identify usability problems and collect quantitative- and qualitative data to determine the overall satisfaction with the product or service. Overall, a usability test can evaluate a product or service to the representative users.

% A usability test on the Arc language aims to determine how Arc performs compared to other languages/libraries when it comes to how easy it is to write concurrency. Therefore, Arc will be evaluated on the ease of use to write concurrency and not how fast it executes its memory usages, or other performance-related metrics.

\subsection{Aim of the test}\label{subsubsec:aimOfTheTest}

The usability test aims to determine how the Arc language meassures up to our preformed expectations, as seen in [ref: table 3.2]. Arc would be evaluated by the Language Evaluation Criteria, as seen in [ref: table 3.1]. The focus of this project has mostly been on simplicity and syntax design, rather than support for abstraction. However, this test will still cover all of the characteristics to ensure that Arc lives up to the expectations and is easy to use for hobbyist developers. We have arranged the characteristics in [ref: table 3.2] in such a way, that it should make it easier to use concurrency on an Arduino.

We have prepared a set of four questions, that we would have wanted to get answered by the results of this test. These four questions are as follows:

\begin{enumerate}
    \item How easy is it to get familiar with and use Arc?
    \item What does a beggining programmer think of Arc?
    \item What does a more experienced programmer think of Arc and how does it compare to other programming languages?
    \item How would an evaluation of Arc based on the Language Evaluation Criteria by the experienced developer look?
\end{enumerate}

% The usability test aims to determine how Arc performs compared to other programming languages/libraries and to see if the Arc language has lived up to our expectations, as seen in [ref: table 3.2]. The metrics the performance will be based on are how easy Arc is to use. The metrics in mind here are those criteria from the Language evaluation criteria, which can be seen in [ref: table 3.1]. As mentioned in [ref: table 3.2], we have focused more on simplicity and syntax design rather than support for abstraction. However, this test will still cover all of the characteristics to ensure that Arc lives up to the expectations and is easy to use for new programmers. We have arranged the characteristics in [ref: table 3.2] the way we have, because Arc was created to ease the use of how to write concurrency.

% The most important thing to test in this usability test is to cover all the different characteristics to show that the Arc language lives up to its intended expectations.

% The following questions that must be covered when this test has been conducted
%    How easy is Arc to get familiar with and get up to speed with?
%    What does the new programmer think of Arc?
%    What do more experienced programmers think of Arc compared to another programming language?
%    How would the experienced programmer evaluate Arc using the Language Evaluate Criteria?

\subsection{The test participants}\label{subsubsec:theTestParticipants}

For this usability test, we would need participants with a varied amount of programming experience. We would need to divide them into two main groups: novice- and experienced programmers. In the scenario we were to conduct the test, we would also have to account for the distinction between a novice- and experienced programmer - in case we had an intermediate programmer who has too much experience to be a novice but too little experience to be considered an experienced programmer; but as this is only hypothetical, we will make do with our two categories for now. The novice programmer would be needed to indicate how easy beginning programmers might find the Arc language to understand and use, while the experienced programmer would be able to provide us with a new perspective on our language and evaluate it based on their personal experience and give a more constructive opinion on the language. The data collected from both the novice- and experienced programmers, would help to indicate how easy the language really is to understand and use.

By having the experienced programmers evaluate our language using the Language Evaluation Criterias, we could compare their results to our own evaluation and check whether or not they agreed with our own assessment.

It is typically best to have as many participants as possible for a usability test to provide the best possible results; but we would only need a handfull of participants in each group to have sufficient results for the purposes of this test.

% For this usability test, the participants need different programming skills to be divided into two groups, each presenting the novice and experienced programmers. The novice programmer is needed to determine whether or not Arc would be a great language to start with. The data from both the novice- and experienced programmers will indicate the ease of use of Arc.

% The experienced programmers would be needed to compare Arc to other programming languages. As well as their knowledge or usage of the different programming languages will also be excellent for determining which part of Arc would work well and which parts would not work so well. It would also be helpful to get the experienced programmer to evaluate Arc using the Language Evaluate Criteria, which we can compare to our own to determine if our language lived up to the expectations.

% It is always best to have as many participants as possible for the usability test to give the best results. Nevertheless, in this case, three to four participants for each novice- and experienced programmer should be enough to give us sufficient data within the time frame of this semester.

\subsection{The test session}\label{subsubsec:theTestSession}

Each test participant would have a similar looking individual test session - perhaps with different questions prepared for each of the groups, to better reflect their programming experience. For example, while it makes little sense to ask the novice programmer to evaluate the language using the Language Evaluation Criteria, it would be considered a missed opportunity not to ask that of the experienced programmer.

The test would be fully documented, and recorded to capture the participant's reactions and actions during the test if the participant approves and allows us to record, that is. A designated test moderator would then instruct the participant on how to complete the test while being impartial and trying not to influence the test results in any way and in any case as little as possible. The test moderator would also have to inform the participant to think aloud during the test to provide us with more data about their thought process while completing the tasks from the task list. This would help us evaluate the results and better distinguish the severity of any potential problems. The test would also be supervised by at least one other observer responsible for taking notes during the test.

Once the test would be completed, the moderator would have a set of prepared questions to help the participant evaluate the Arc language. A set of questions for the novice programmers could look like this:

\begin{enumerate}
    \item How would you rate the Arc language as a beginner friendly programming language?
    \item How does it compare to any other programming language you might know of?
    \item How easy did you find the task function to work with when constructing new threads?
    \item Would you recommend other developers to use Arc, why or why not?
\end{enumerate}

While a set of questions prepared for the experienced programmers could look like this:

\begin{enumerate}
    \item How did the Arc language compare to your first programming language, with focus on simplicity?
    \item How does it compare to any other programming languages you have used in the past?
    \item Do you have any prior experience with concurrency and/or the Arduino?
    \item How would you evaluate the Arc language based on these Language Evaluation Criteria?
\end{enumerate}

% For each of the test participants, a test session will be conducted. If the participant allows it, the session will be recorded to capture the participant's reactions and actions. A test moderator will instruct the participant on what to do and help them if necessary for each test session. When conducting the test sessions, the moderator must be impartial and not influence the test results.

% During a test session, the test moderator will tell the participant where the test will be conducted and which task they will attempt to complete during the test session. The test moderator needs to tell the participant to think aloud during the test session since the data will be analyzed and used to help evaluate the Arc language. If the participant does not have any questions, the test may begin. A session should not take more than 15 to 30 minutes, depending on the participant and how many questions they have asked asked during the session. Besides the test moderator, there will be a test observer who takes notes of how and what the test participant did.

% When a test participant is conducting the test, the test moderator must not interrupt the participant, as it is essential to get accurate impressions of their actions and reactions of the Arc language. If the participant stops thinking aloud, the test moderator must remind them to do so since collecting this kind of data is crucial. If the participant does not have any questions, the moderator will ask questions to both the novice- and experienced programmers.

% The question for the novice programmers could be:
%    What do you think of Arc as a starting programming language?
%    Furthermore, how was it to Arc instead of your everyday language?
%    Did the task() function make it easier to construct new threads?
%    Would you recommend Arc to other people as their first language?

% The questions for the experienced programmers could be like:
%    With focus on the simplicity of Arc, how did it compare to your first programming language?
%    Which things worked well? And if something did not work for you, what was it?
%    How would you evaluate the Arc language based on the Language Evaluation Criteria?

\subsection{Task list}\label{subsubsec:taskList}

We have prepared a set of imaginary tasks to present out thought process as to how we would have approached designing the tasks for the participants. Each task would have to be solved by the participant with as little help from the moderator as possible. First and foremost, we would have to test the readability and writability of the language. One way to do this would be to have them read some preformed tasks such as tasks that:

\begin{enumerate}
    \item Toggles an LED on and off every second.
    \item Toggles an LED on and off when a condition has been met, such as a button press.
    \item Reads the state of a button as often as it can, unconditionally and without a sense of time.
\end{enumerate}

The idea is then for the participant to explain what is going on in each of the tasks using their own words and as little or as much terminology as they are comfortable with. The purpose is to test how easily they understand what happens in the code. After having seen some examples of the tasks, they would be tasked to create their own tasks using Arc. They would have to create the same tasks as they had already seen or at least similar tasks. The purpose is to test how intuitively and easy the code is to write.

% The following task would be the task the novice- and experienced programmers would have to solve to help give us data to determine if Arc would live up to the criteria.
% I dont exactly know which task could be nice to do put these is my examples ¯\_(ツ)_/¯
%   Read a task() that turns a led on and off every one second with your own words to see if it is easy to read
%   Read a task() that turns a led on based on a condition with your own words to see if it is easy to read
%   Read a task() that turns a led on and off with no time delay of condition with your own words to see if it is easy to read
%   Create a task() that turns a led on and off every one second
%   Create a task() that turns a led on based on a condition
%   Create a task() that turns a led on and off with no time delay of condition

\subsection{Analysis of the data}\label{subsubsec:analysisOfTheData}

After having conducted all of the tests, we would have to analyse all of the gathered data and compare the results. The first natural thing to do would be to go over the notes made by the test observer and the recorded material. For example, if one of the participants was stuck during a task - it could indicate that the participant had an issue with something; but if a multitude of the participants had a similar issue - it would indicate that something might be innately wrong with either the language or the task itself.

The next step would be to go over the findings made from observing the participants familiarising themselves with and working with the language. Obviously, it would be the first time both the novice- and experienced programmers sees the language, and while a learning curve can be expected with all new things, a certain margin of error is to be expected with all of the results due to this. However, it would also be interesting to see how much of a difference there is between the two groups when it comes to the ease of learning the Arc language and how well and fast they would be to complete their designated tasks. If the time difference between the two groups is insignificant, then that might imply the language to be easy to understand. More interestingly, in our effort to simplify and make our language easy to use for beginners, we might learn that we have made it more difficult for users with more programming experience to intuitively write the code and understand why we have done as we have. This would be reflected by results that indicate the novice programmers being faster at completing the tasks than the experienced programmers. Any time comparisons would also have to acknowledge that one programmer could have received a lot of help to complete a task while another could have received no help at all and does not reflect the complete result.

The final thing to analyse would be the individual replies to the prepared questions that came after the test had concluded. It would be interesting to see how different the answers to the shared questions would be and how the respondents answers the individual questions for their specific group. Most interestingly, perhaps, would be to compare the experienced programmers' evaluations of the language to that of our own, using the Language Evaluation Criteria.

% After the test sessions have been conducted, all the data gathered from the test sessions would have to be analyzed. However, as there was no time this semester's timeframe to conduct the test, this section will only describe what we would have been analyzing and looking into.

% After conducting the test sessions, the first thing that needs to be done is to go through the test observer's notes and the recorded material to check what led the observer to take the notes one did. An example could be: If one of the participants got stuck on a task and said something about it being confusing to read the task() with the conditional. The test observer's notes should match the problem, so later on, this problem can be taken in to evaluating the Arc language. If multiple test participants had the same problem where they had a hard time continuing, this would have to be reviewed more extensively, as this could potentially mean that something is not as it is supposed to be.

% The next thing that should be spent time analyzing is the test participant's answers to the question asked throughout the test session. These answers should contain vital information about how Arc performed and what it was like to use Arc as a programming language. A question that will be especially important to analyze is what the experienced programmer answered to how they would evaluate the Arc language based on the Language Evaluate Criteria. The answers would have to be compared to the other answers and our expectations for the Arc language for differences and similarities.

% Another thing worth comparing is the time difference between how quickly the novice and the experienced programmer finished the task. If the time difference is not significant, it might indicate that the Arc language is simple and easy to read and write, which means that the language lives up to the expected criteria. As all participants have been asked the same number of questions, it will not be unfair to compare the time difference. Keep in mind that comparing the time difference would be insufficient if the novice programmers got more help than the experienced programmers. 

% Time is just one thing that can be compared. Another thing like the number of questions and how well they formulated the questions could also be analyzed and compared, as this would also indicate how easy or hard the language was to use for each of the groups of programmers.